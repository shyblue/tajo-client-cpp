// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ClientProtos.proto

#ifndef PROTOBUF_ClientProtos_2eproto__INCLUDED
#define PROTOBUF_ClientProtos_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "tajo_protos.pb.h"
#include "TajoIdProtos.pb.h"
#include "CatalogProtos.pb.h"
#include "PrimitiveProtos.pb.h"
#include "DataTypes.pb.h"
// @@protoc_insertion_point(includes)

namespace tajo {
namespace client {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ClientProtos_2eproto();
void protobuf_AssignDesc_ClientProtos_2eproto();
void protobuf_ShutdownFile_ClientProtos_2eproto();

class CreateSessionRequest;
class CreateSessionResponse;
class UpdateSessionVariableRequest;
class SessionUpdateResponse;
class SessionedStringProto;
class ExplainQueryResponse;
class QueryRequest;
class UpdateQueryResponse;
class GetQueryResultRequest;
class GetQueryResultResponse;
class QueryIdRequest;
class GetQueryListRequest;
class BriefQueryInfo;
class GetQueryListResponse;
class GetQueryStatusRequest;
class SerializedResultSet;
class SubmitQueryResponse;
class GetQueryStatusResponse;
class GetQueryResultDataRequest;
class GetQueryResultDataResponse;
class GetClusterInfoRequest;
class WorkerResourceInfo;
class GetClusterInfoResponse;
class CreateTableRequest;
class DropTableRequest;
class QueryInfoProto;
class StageHistoryProto;
class QueryHistoryProto;
class GetQueryHistoryResponse;
class GetQueryInfoResponse;
class CreateIndexResponse;
class GetIndexWithColumnsRequest;

enum SubmitQueryResponse_ResultType {
  SubmitQueryResponse_ResultType_NO_RESULT = 0,
  SubmitQueryResponse_ResultType_ENCLOSED = 1,
  SubmitQueryResponse_ResultType_FETCH = 2
};
bool SubmitQueryResponse_ResultType_IsValid(int value);
const SubmitQueryResponse_ResultType SubmitQueryResponse_ResultType_ResultType_MIN = SubmitQueryResponse_ResultType_NO_RESULT;
const SubmitQueryResponse_ResultType SubmitQueryResponse_ResultType_ResultType_MAX = SubmitQueryResponse_ResultType_FETCH;
const int SubmitQueryResponse_ResultType_ResultType_ARRAYSIZE = SubmitQueryResponse_ResultType_ResultType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SubmitQueryResponse_ResultType_descriptor();
inline const ::std::string& SubmitQueryResponse_ResultType_Name(SubmitQueryResponse_ResultType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SubmitQueryResponse_ResultType_descriptor(), value);
}
inline bool SubmitQueryResponse_ResultType_Parse(
    const ::std::string& name, SubmitQueryResponse_ResultType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SubmitQueryResponse_ResultType>(
    SubmitQueryResponse_ResultType_descriptor(), name, value);
}
// ===================================================================

class CreateSessionRequest : public ::google::protobuf::Message {
 public:
  CreateSessionRequest();
  virtual ~CreateSessionRequest();

  CreateSessionRequest(const CreateSessionRequest& from);

  inline CreateSessionRequest& operator=(const CreateSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateSessionRequest& default_instance();

  void Swap(CreateSessionRequest* other);

  // implements Message ----------------------------------------------

  CreateSessionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateSessionRequest& from);
  void MergeFrom(const CreateSessionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string baseDatabaseName = 2;
  inline bool has_basedatabasename() const;
  inline void clear_basedatabasename();
  static const int kBaseDatabaseNameFieldNumber = 2;
  inline const ::std::string& basedatabasename() const;
  inline void set_basedatabasename(const ::std::string& value);
  inline void set_basedatabasename(const char* value);
  inline void set_basedatabasename(const char* value, size_t size);
  inline ::std::string* mutable_basedatabasename();
  inline ::std::string* release_basedatabasename();
  inline void set_allocated_basedatabasename(::std::string* basedatabasename);

  // @@protoc_insertion_point(class_scope:tajo.client.CreateSessionRequest)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_basedatabasename();
  inline void clear_has_basedatabasename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* basedatabasename_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static CreateSessionRequest* default_instance_;
};
// -------------------------------------------------------------------

class CreateSessionResponse : public ::google::protobuf::Message {
 public:
  CreateSessionResponse();
  virtual ~CreateSessionResponse();

  CreateSessionResponse(const CreateSessionResponse& from);

  inline CreateSessionResponse& operator=(const CreateSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateSessionResponse& default_instance();

  void Swap(CreateSessionResponse* other);

  // implements Message ----------------------------------------------

  CreateSessionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateSessionResponse& from);
  void MergeFrom(const CreateSessionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ReturnState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline const ::ReturnState& state() const;
  inline ::ReturnState* mutable_state();
  inline ::ReturnState* release_state();
  inline void set_allocated_state(::ReturnState* state);

  // optional .SessionIdProto sessionId = 2;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 2;
  inline const ::SessionIdProto& sessionid() const;
  inline ::SessionIdProto* mutable_sessionid();
  inline ::SessionIdProto* release_sessionid();
  inline void set_allocated_sessionid(::SessionIdProto* sessionid);

  // optional .KeyValueSetProto sessionVars = 3;
  inline bool has_sessionvars() const;
  inline void clear_sessionvars();
  static const int kSessionVarsFieldNumber = 3;
  inline const ::KeyValueSetProto& sessionvars() const;
  inline ::KeyValueSetProto* mutable_sessionvars();
  inline ::KeyValueSetProto* release_sessionvars();
  inline void set_allocated_sessionvars(::KeyValueSetProto* sessionvars);

  // @@protoc_insertion_point(class_scope:tajo.client.CreateSessionResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_sessionvars();
  inline void clear_has_sessionvars();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ReturnState* state_;
  ::SessionIdProto* sessionid_;
  ::KeyValueSetProto* sessionvars_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static CreateSessionResponse* default_instance_;
};
// -------------------------------------------------------------------

class UpdateSessionVariableRequest : public ::google::protobuf::Message {
 public:
  UpdateSessionVariableRequest();
  virtual ~UpdateSessionVariableRequest();

  UpdateSessionVariableRequest(const UpdateSessionVariableRequest& from);

  inline UpdateSessionVariableRequest& operator=(const UpdateSessionVariableRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateSessionVariableRequest& default_instance();

  void Swap(UpdateSessionVariableRequest* other);

  // implements Message ----------------------------------------------

  UpdateSessionVariableRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateSessionVariableRequest& from);
  void MergeFrom(const UpdateSessionVariableRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SessionIdProto sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline const ::SessionIdProto& sessionid() const;
  inline ::SessionIdProto* mutable_sessionid();
  inline ::SessionIdProto* release_sessionid();
  inline void set_allocated_sessionid(::SessionIdProto* sessionid);

  // optional .KeyValueSetProto sessionVars = 2;
  inline bool has_sessionvars() const;
  inline void clear_sessionvars();
  static const int kSessionVarsFieldNumber = 2;
  inline const ::KeyValueSetProto& sessionvars() const;
  inline ::KeyValueSetProto* mutable_sessionvars();
  inline ::KeyValueSetProto* release_sessionvars();
  inline void set_allocated_sessionvars(::KeyValueSetProto* sessionvars);

  // repeated string unsetVariables = 3;
  inline int unsetvariables_size() const;
  inline void clear_unsetvariables();
  static const int kUnsetVariablesFieldNumber = 3;
  inline const ::std::string& unsetvariables(int index) const;
  inline ::std::string* mutable_unsetvariables(int index);
  inline void set_unsetvariables(int index, const ::std::string& value);
  inline void set_unsetvariables(int index, const char* value);
  inline void set_unsetvariables(int index, const char* value, size_t size);
  inline ::std::string* add_unsetvariables();
  inline void add_unsetvariables(const ::std::string& value);
  inline void add_unsetvariables(const char* value);
  inline void add_unsetvariables(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& unsetvariables() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_unsetvariables();

  // @@protoc_insertion_point(class_scope:tajo.client.UpdateSessionVariableRequest)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_sessionvars();
  inline void clear_has_sessionvars();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SessionIdProto* sessionid_;
  ::KeyValueSetProto* sessionvars_;
  ::google::protobuf::RepeatedPtrField< ::std::string> unsetvariables_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static UpdateSessionVariableRequest* default_instance_;
};
// -------------------------------------------------------------------

class SessionUpdateResponse : public ::google::protobuf::Message {
 public:
  SessionUpdateResponse();
  virtual ~SessionUpdateResponse();

  SessionUpdateResponse(const SessionUpdateResponse& from);

  inline SessionUpdateResponse& operator=(const SessionUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionUpdateResponse& default_instance();

  void Swap(SessionUpdateResponse* other);

  // implements Message ----------------------------------------------

  SessionUpdateResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SessionUpdateResponse& from);
  void MergeFrom(const SessionUpdateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ReturnState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline const ::ReturnState& state() const;
  inline ::ReturnState* mutable_state();
  inline ::ReturnState* release_state();
  inline void set_allocated_state(::ReturnState* state);

  // optional .KeyValueSetProto sessionVars = 2;
  inline bool has_sessionvars() const;
  inline void clear_sessionvars();
  static const int kSessionVarsFieldNumber = 2;
  inline const ::KeyValueSetProto& sessionvars() const;
  inline ::KeyValueSetProto* mutable_sessionvars();
  inline ::KeyValueSetProto* release_sessionvars();
  inline void set_allocated_sessionvars(::KeyValueSetProto* sessionvars);

  // @@protoc_insertion_point(class_scope:tajo.client.SessionUpdateResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_sessionvars();
  inline void clear_has_sessionvars();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ReturnState* state_;
  ::KeyValueSetProto* sessionvars_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static SessionUpdateResponse* default_instance_;
};
// -------------------------------------------------------------------

class SessionedStringProto : public ::google::protobuf::Message {
 public:
  SessionedStringProto();
  virtual ~SessionedStringProto();

  SessionedStringProto(const SessionedStringProto& from);

  inline SessionedStringProto& operator=(const SessionedStringProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionedStringProto& default_instance();

  void Swap(SessionedStringProto* other);

  // implements Message ----------------------------------------------

  SessionedStringProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SessionedStringProto& from);
  void MergeFrom(const SessionedStringProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SessionIdProto sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline const ::SessionIdProto& sessionid() const;
  inline ::SessionIdProto* mutable_sessionid();
  inline ::SessionIdProto* release_sessionid();
  inline void set_allocated_sessionid(::SessionIdProto* sessionid);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:tajo.client.SessionedStringProto)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SessionIdProto* sessionid_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static SessionedStringProto* default_instance_;
};
// -------------------------------------------------------------------

class ExplainQueryResponse : public ::google::protobuf::Message {
 public:
  ExplainQueryResponse();
  virtual ~ExplainQueryResponse();

  ExplainQueryResponse(const ExplainQueryResponse& from);

  inline ExplainQueryResponse& operator=(const ExplainQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExplainQueryResponse& default_instance();

  void Swap(ExplainQueryResponse* other);

  // implements Message ----------------------------------------------

  ExplainQueryResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExplainQueryResponse& from);
  void MergeFrom(const ExplainQueryResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ReturnState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline const ::ReturnState& state() const;
  inline ::ReturnState* mutable_state();
  inline ::ReturnState* release_state();
  inline void set_allocated_state(::ReturnState* state);

  // optional string explain = 2;
  inline bool has_explain() const;
  inline void clear_explain();
  static const int kExplainFieldNumber = 2;
  inline const ::std::string& explain() const;
  inline void set_explain(const ::std::string& value);
  inline void set_explain(const char* value);
  inline void set_explain(const char* value, size_t size);
  inline ::std::string* mutable_explain();
  inline ::std::string* release_explain();
  inline void set_allocated_explain(::std::string* explain);

  // @@protoc_insertion_point(class_scope:tajo.client.ExplainQueryResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_explain();
  inline void clear_has_explain();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ReturnState* state_;
  ::std::string* explain_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static ExplainQueryResponse* default_instance_;
};
// -------------------------------------------------------------------

class QueryRequest : public ::google::protobuf::Message {
 public:
  QueryRequest();
  virtual ~QueryRequest();

  QueryRequest(const QueryRequest& from);

  inline QueryRequest& operator=(const QueryRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryRequest& default_instance();

  void Swap(QueryRequest* other);

  // implements Message ----------------------------------------------

  QueryRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryRequest& from);
  void MergeFrom(const QueryRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SessionIdProto sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline const ::SessionIdProto& sessionid() const;
  inline ::SessionIdProto* mutable_sessionid();
  inline ::SessionIdProto* release_sessionid();
  inline void set_allocated_sessionid(::SessionIdProto* sessionid);

  // required string query = 2;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 2;
  inline const ::std::string& query() const;
  inline void set_query(const ::std::string& value);
  inline void set_query(const char* value);
  inline void set_query(const char* value, size_t size);
  inline ::std::string* mutable_query();
  inline ::std::string* release_query();
  inline void set_allocated_query(::std::string* query);

  // repeated .KeyValueProto sessionVars = 3;
  inline int sessionvars_size() const;
  inline void clear_sessionvars();
  static const int kSessionVarsFieldNumber = 3;
  inline const ::KeyValueProto& sessionvars(int index) const;
  inline ::KeyValueProto* mutable_sessionvars(int index);
  inline ::KeyValueProto* add_sessionvars();
  inline const ::google::protobuf::RepeatedPtrField< ::KeyValueProto >&
      sessionvars() const;
  inline ::google::protobuf::RepeatedPtrField< ::KeyValueProto >*
      mutable_sessionvars();

  // required bool isJson = 4;
  inline bool has_isjson() const;
  inline void clear_isjson();
  static const int kIsJsonFieldNumber = 4;
  inline bool isjson() const;
  inline void set_isjson(bool value);

  // @@protoc_insertion_point(class_scope:tajo.client.QueryRequest)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_query();
  inline void clear_has_query();
  inline void set_has_isjson();
  inline void clear_has_isjson();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SessionIdProto* sessionid_;
  ::std::string* query_;
  ::google::protobuf::RepeatedPtrField< ::KeyValueProto > sessionvars_;
  bool isjson_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static QueryRequest* default_instance_;
};
// -------------------------------------------------------------------

class UpdateQueryResponse : public ::google::protobuf::Message {
 public:
  UpdateQueryResponse();
  virtual ~UpdateQueryResponse();

  UpdateQueryResponse(const UpdateQueryResponse& from);

  inline UpdateQueryResponse& operator=(const UpdateQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateQueryResponse& default_instance();

  void Swap(UpdateQueryResponse* other);

  // implements Message ----------------------------------------------

  UpdateQueryResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateQueryResponse& from);
  void MergeFrom(const UpdateQueryResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ReturnState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline const ::ReturnState& state() const;
  inline ::ReturnState* mutable_state();
  inline ::ReturnState* release_state();
  inline void set_allocated_state(::ReturnState* state);

  // optional .KeyValueSetProto sessionVars = 2;
  inline bool has_sessionvars() const;
  inline void clear_sessionvars();
  static const int kSessionVarsFieldNumber = 2;
  inline const ::KeyValueSetProto& sessionvars() const;
  inline ::KeyValueSetProto* mutable_sessionvars();
  inline ::KeyValueSetProto* release_sessionvars();
  inline void set_allocated_sessionvars(::KeyValueSetProto* sessionvars);

  // @@protoc_insertion_point(class_scope:tajo.client.UpdateQueryResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_sessionvars();
  inline void clear_has_sessionvars();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ReturnState* state_;
  ::KeyValueSetProto* sessionvars_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static UpdateQueryResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetQueryResultRequest : public ::google::protobuf::Message {
 public:
  GetQueryResultRequest();
  virtual ~GetQueryResultRequest();

  GetQueryResultRequest(const GetQueryResultRequest& from);

  inline GetQueryResultRequest& operator=(const GetQueryResultRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetQueryResultRequest& default_instance();

  void Swap(GetQueryResultRequest* other);

  // implements Message ----------------------------------------------

  GetQueryResultRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetQueryResultRequest& from);
  void MergeFrom(const GetQueryResultRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SessionIdProto sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline const ::SessionIdProto& sessionid() const;
  inline ::SessionIdProto* mutable_sessionid();
  inline ::SessionIdProto* release_sessionid();
  inline void set_allocated_sessionid(::SessionIdProto* sessionid);

  // required .QueryIdProto queryId = 2;
  inline bool has_queryid() const;
  inline void clear_queryid();
  static const int kQueryIdFieldNumber = 2;
  inline const ::QueryIdProto& queryid() const;
  inline ::QueryIdProto* mutable_queryid();
  inline ::QueryIdProto* release_queryid();
  inline void set_allocated_queryid(::QueryIdProto* queryid);

  // @@protoc_insertion_point(class_scope:tajo.client.GetQueryResultRequest)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_queryid();
  inline void clear_has_queryid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SessionIdProto* sessionid_;
  ::QueryIdProto* queryid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static GetQueryResultRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetQueryResultResponse : public ::google::protobuf::Message {
 public:
  GetQueryResultResponse();
  virtual ~GetQueryResultResponse();

  GetQueryResultResponse(const GetQueryResultResponse& from);

  inline GetQueryResultResponse& operator=(const GetQueryResultResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetQueryResultResponse& default_instance();

  void Swap(GetQueryResultResponse* other);

  // implements Message ----------------------------------------------

  GetQueryResultResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetQueryResultResponse& from);
  void MergeFrom(const GetQueryResultResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ReturnState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline const ::ReturnState& state() const;
  inline ::ReturnState* mutable_state();
  inline ::ReturnState* release_state();
  inline void set_allocated_state(::ReturnState* state);

  // optional .TableDescProto tableDesc = 2;
  inline bool has_tabledesc() const;
  inline void clear_tabledesc();
  static const int kTableDescFieldNumber = 2;
  inline const ::TableDescProto& tabledesc() const;
  inline ::TableDescProto* mutable_tabledesc();
  inline ::TableDescProto* release_tabledesc();
  inline void set_allocated_tabledesc(::TableDescProto* tabledesc);

  // optional string tajoUserName = 3;
  inline bool has_tajousername() const;
  inline void clear_tajousername();
  static const int kTajoUserNameFieldNumber = 3;
  inline const ::std::string& tajousername() const;
  inline void set_tajousername(const ::std::string& value);
  inline void set_tajousername(const char* value);
  inline void set_tajousername(const char* value, size_t size);
  inline ::std::string* mutable_tajousername();
  inline ::std::string* release_tajousername();
  inline void set_allocated_tajousername(::std::string* tajousername);

  // @@protoc_insertion_point(class_scope:tajo.client.GetQueryResultResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_tabledesc();
  inline void clear_has_tabledesc();
  inline void set_has_tajousername();
  inline void clear_has_tajousername();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ReturnState* state_;
  ::TableDescProto* tabledesc_;
  ::std::string* tajousername_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static GetQueryResultResponse* default_instance_;
};
// -------------------------------------------------------------------

class QueryIdRequest : public ::google::protobuf::Message {
 public:
  QueryIdRequest();
  virtual ~QueryIdRequest();

  QueryIdRequest(const QueryIdRequest& from);

  inline QueryIdRequest& operator=(const QueryIdRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryIdRequest& default_instance();

  void Swap(QueryIdRequest* other);

  // implements Message ----------------------------------------------

  QueryIdRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryIdRequest& from);
  void MergeFrom(const QueryIdRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SessionIdProto sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline const ::SessionIdProto& sessionid() const;
  inline ::SessionIdProto* mutable_sessionid();
  inline ::SessionIdProto* release_sessionid();
  inline void set_allocated_sessionid(::SessionIdProto* sessionid);

  // required .QueryIdProto queryId = 2;
  inline bool has_queryid() const;
  inline void clear_queryid();
  static const int kQueryIdFieldNumber = 2;
  inline const ::QueryIdProto& queryid() const;
  inline ::QueryIdProto* mutable_queryid();
  inline ::QueryIdProto* release_queryid();
  inline void set_allocated_queryid(::QueryIdProto* queryid);

  // @@protoc_insertion_point(class_scope:tajo.client.QueryIdRequest)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_queryid();
  inline void clear_has_queryid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SessionIdProto* sessionid_;
  ::QueryIdProto* queryid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static QueryIdRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetQueryListRequest : public ::google::protobuf::Message {
 public:
  GetQueryListRequest();
  virtual ~GetQueryListRequest();

  GetQueryListRequest(const GetQueryListRequest& from);

  inline GetQueryListRequest& operator=(const GetQueryListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetQueryListRequest& default_instance();

  void Swap(GetQueryListRequest* other);

  // implements Message ----------------------------------------------

  GetQueryListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetQueryListRequest& from);
  void MergeFrom(const GetQueryListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SessionIdProto sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline const ::SessionIdProto& sessionid() const;
  inline ::SessionIdProto* mutable_sessionid();
  inline ::SessionIdProto* release_sessionid();
  inline void set_allocated_sessionid(::SessionIdProto* sessionid);

  // @@protoc_insertion_point(class_scope:tajo.client.GetQueryListRequest)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SessionIdProto* sessionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static GetQueryListRequest* default_instance_;
};
// -------------------------------------------------------------------

class BriefQueryInfo : public ::google::protobuf::Message {
 public:
  BriefQueryInfo();
  virtual ~BriefQueryInfo();

  BriefQueryInfo(const BriefQueryInfo& from);

  inline BriefQueryInfo& operator=(const BriefQueryInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BriefQueryInfo& default_instance();

  void Swap(BriefQueryInfo* other);

  // implements Message ----------------------------------------------

  BriefQueryInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BriefQueryInfo& from);
  void MergeFrom(const BriefQueryInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .QueryIdProto queryId = 1;
  inline bool has_queryid() const;
  inline void clear_queryid();
  static const int kQueryIdFieldNumber = 1;
  inline const ::QueryIdProto& queryid() const;
  inline ::QueryIdProto* mutable_queryid();
  inline ::QueryIdProto* release_queryid();
  inline void set_allocated_queryid(::QueryIdProto* queryid);

  // required .QueryState state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::QueryState state() const;
  inline void set_state(::QueryState value);

  // required int64 startTime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 3;
  inline ::google::protobuf::int64 starttime() const;
  inline void set_starttime(::google::protobuf::int64 value);

  // required int64 finishTime = 4;
  inline bool has_finishtime() const;
  inline void clear_finishtime();
  static const int kFinishTimeFieldNumber = 4;
  inline ::google::protobuf::int64 finishtime() const;
  inline void set_finishtime(::google::protobuf::int64 value);

  // required string query = 5;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 5;
  inline const ::std::string& query() const;
  inline void set_query(const ::std::string& value);
  inline void set_query(const char* value);
  inline void set_query(const char* value, size_t size);
  inline ::std::string* mutable_query();
  inline ::std::string* release_query();
  inline void set_allocated_query(::std::string* query);

  // optional string queryMasterHost = 6;
  inline bool has_querymasterhost() const;
  inline void clear_querymasterhost();
  static const int kQueryMasterHostFieldNumber = 6;
  inline const ::std::string& querymasterhost() const;
  inline void set_querymasterhost(const ::std::string& value);
  inline void set_querymasterhost(const char* value);
  inline void set_querymasterhost(const char* value, size_t size);
  inline ::std::string* mutable_querymasterhost();
  inline ::std::string* release_querymasterhost();
  inline void set_allocated_querymasterhost(::std::string* querymasterhost);

  // optional int32 queryMasterPort = 7;
  inline bool has_querymasterport() const;
  inline void clear_querymasterport();
  static const int kQueryMasterPortFieldNumber = 7;
  inline ::google::protobuf::int32 querymasterport() const;
  inline void set_querymasterport(::google::protobuf::int32 value);

  // required float progress = 8;
  inline bool has_progress() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 8;
  inline float progress() const;
  inline void set_progress(float value);

  // @@protoc_insertion_point(class_scope:tajo.client.BriefQueryInfo)
 private:
  inline void set_has_queryid();
  inline void clear_has_queryid();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_finishtime();
  inline void clear_has_finishtime();
  inline void set_has_query();
  inline void clear_has_query();
  inline void set_has_querymasterhost();
  inline void clear_has_querymasterhost();
  inline void set_has_querymasterport();
  inline void clear_has_querymasterport();
  inline void set_has_progress();
  inline void clear_has_progress();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::QueryIdProto* queryid_;
  ::google::protobuf::int64 starttime_;
  ::google::protobuf::int64 finishtime_;
  int state_;
  ::google::protobuf::int32 querymasterport_;
  ::std::string* query_;
  ::std::string* querymasterhost_;
  float progress_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static BriefQueryInfo* default_instance_;
};
// -------------------------------------------------------------------

class GetQueryListResponse : public ::google::protobuf::Message {
 public:
  GetQueryListResponse();
  virtual ~GetQueryListResponse();

  GetQueryListResponse(const GetQueryListResponse& from);

  inline GetQueryListResponse& operator=(const GetQueryListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetQueryListResponse& default_instance();

  void Swap(GetQueryListResponse* other);

  // implements Message ----------------------------------------------

  GetQueryListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetQueryListResponse& from);
  void MergeFrom(const GetQueryListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ReturnState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline const ::ReturnState& state() const;
  inline ::ReturnState* mutable_state();
  inline ::ReturnState* release_state();
  inline void set_allocated_state(::ReturnState* state);

  // repeated .tajo.client.BriefQueryInfo queryList = 2;
  inline int querylist_size() const;
  inline void clear_querylist();
  static const int kQueryListFieldNumber = 2;
  inline const ::tajo::client::BriefQueryInfo& querylist(int index) const;
  inline ::tajo::client::BriefQueryInfo* mutable_querylist(int index);
  inline ::tajo::client::BriefQueryInfo* add_querylist();
  inline const ::google::protobuf::RepeatedPtrField< ::tajo::client::BriefQueryInfo >&
      querylist() const;
  inline ::google::protobuf::RepeatedPtrField< ::tajo::client::BriefQueryInfo >*
      mutable_querylist();

  // @@protoc_insertion_point(class_scope:tajo.client.GetQueryListResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ReturnState* state_;
  ::google::protobuf::RepeatedPtrField< ::tajo::client::BriefQueryInfo > querylist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static GetQueryListResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetQueryStatusRequest : public ::google::protobuf::Message {
 public:
  GetQueryStatusRequest();
  virtual ~GetQueryStatusRequest();

  GetQueryStatusRequest(const GetQueryStatusRequest& from);

  inline GetQueryStatusRequest& operator=(const GetQueryStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetQueryStatusRequest& default_instance();

  void Swap(GetQueryStatusRequest* other);

  // implements Message ----------------------------------------------

  GetQueryStatusRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetQueryStatusRequest& from);
  void MergeFrom(const GetQueryStatusRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SessionIdProto sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline const ::SessionIdProto& sessionid() const;
  inline ::SessionIdProto* mutable_sessionid();
  inline ::SessionIdProto* release_sessionid();
  inline void set_allocated_sessionid(::SessionIdProto* sessionid);

  // required .QueryIdProto queryId = 2;
  inline bool has_queryid() const;
  inline void clear_queryid();
  static const int kQueryIdFieldNumber = 2;
  inline const ::QueryIdProto& queryid() const;
  inline ::QueryIdProto* mutable_queryid();
  inline ::QueryIdProto* release_queryid();
  inline void set_allocated_queryid(::QueryIdProto* queryid);

  // @@protoc_insertion_point(class_scope:tajo.client.GetQueryStatusRequest)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_queryid();
  inline void clear_has_queryid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SessionIdProto* sessionid_;
  ::QueryIdProto* queryid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static GetQueryStatusRequest* default_instance_;
};
// -------------------------------------------------------------------

class SerializedResultSet : public ::google::protobuf::Message {
 public:
  SerializedResultSet();
  virtual ~SerializedResultSet();

  SerializedResultSet(const SerializedResultSet& from);

  inline SerializedResultSet& operator=(const SerializedResultSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SerializedResultSet& default_instance();

  void Swap(SerializedResultSet* other);

  // implements Message ----------------------------------------------

  SerializedResultSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SerializedResultSet& from);
  void MergeFrom(const SerializedResultSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .SchemaProto schema = 1;
  inline bool has_schema() const;
  inline void clear_schema();
  static const int kSchemaFieldNumber = 1;
  inline const ::SchemaProto& schema() const;
  inline ::SchemaProto* mutable_schema();
  inline ::SchemaProto* release_schema();
  inline void set_allocated_schema(::SchemaProto* schema);

  // required int32 rows = 2;
  inline bool has_rows() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 2;
  inline ::google::protobuf::int32 rows() const;
  inline void set_rows(::google::protobuf::int32 value);

  // optional int32 decompressedLength = 3;
  inline bool has_decompressedlength() const;
  inline void clear_decompressedlength();
  static const int kDecompressedLengthFieldNumber = 3;
  inline ::google::protobuf::int32 decompressedlength() const;
  inline void set_decompressedlength(::google::protobuf::int32 value);

  // optional .CodecType decompressCodec = 4;
  inline bool has_decompresscodec() const;
  inline void clear_decompresscodec();
  static const int kDecompressCodecFieldNumber = 4;
  inline ::CodecType decompresscodec() const;
  inline void set_decompresscodec(::CodecType value);

  // optional bytes serializedTuples = 5;
  inline bool has_serializedtuples() const;
  inline void clear_serializedtuples();
  static const int kSerializedTuplesFieldNumber = 5;
  inline const ::std::string& serializedtuples() const;
  inline void set_serializedtuples(const ::std::string& value);
  inline void set_serializedtuples(const char* value);
  inline void set_serializedtuples(const void* value, size_t size);
  inline ::std::string* mutable_serializedtuples();
  inline ::std::string* release_serializedtuples();
  inline void set_allocated_serializedtuples(::std::string* serializedtuples);

  // @@protoc_insertion_point(class_scope:tajo.client.SerializedResultSet)
 private:
  inline void set_has_schema();
  inline void clear_has_schema();
  inline void set_has_rows();
  inline void clear_has_rows();
  inline void set_has_decompressedlength();
  inline void clear_has_decompressedlength();
  inline void set_has_decompresscodec();
  inline void clear_has_decompresscodec();
  inline void set_has_serializedtuples();
  inline void clear_has_serializedtuples();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SchemaProto* schema_;
  ::google::protobuf::int32 rows_;
  ::google::protobuf::int32 decompressedlength_;
  ::std::string* serializedtuples_;
  int decompresscodec_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static SerializedResultSet* default_instance_;
};
// -------------------------------------------------------------------

class SubmitQueryResponse : public ::google::protobuf::Message {
 public:
  SubmitQueryResponse();
  virtual ~SubmitQueryResponse();

  SubmitQueryResponse(const SubmitQueryResponse& from);

  inline SubmitQueryResponse& operator=(const SubmitQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubmitQueryResponse& default_instance();

  void Swap(SubmitQueryResponse* other);

  // implements Message ----------------------------------------------

  SubmitQueryResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubmitQueryResponse& from);
  void MergeFrom(const SubmitQueryResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SubmitQueryResponse_ResultType ResultType;
  static const ResultType NO_RESULT = SubmitQueryResponse_ResultType_NO_RESULT;
  static const ResultType ENCLOSED = SubmitQueryResponse_ResultType_ENCLOSED;
  static const ResultType FETCH = SubmitQueryResponse_ResultType_FETCH;
  static inline bool ResultType_IsValid(int value) {
    return SubmitQueryResponse_ResultType_IsValid(value);
  }
  static const ResultType ResultType_MIN =
    SubmitQueryResponse_ResultType_ResultType_MIN;
  static const ResultType ResultType_MAX =
    SubmitQueryResponse_ResultType_ResultType_MAX;
  static const int ResultType_ARRAYSIZE =
    SubmitQueryResponse_ResultType_ResultType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResultType_descriptor() {
    return SubmitQueryResponse_ResultType_descriptor();
  }
  static inline const ::std::string& ResultType_Name(ResultType value) {
    return SubmitQueryResponse_ResultType_Name(value);
  }
  static inline bool ResultType_Parse(const ::std::string& name,
      ResultType* value) {
    return SubmitQueryResponse_ResultType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ReturnState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline const ::ReturnState& state() const;
  inline ::ReturnState* mutable_state();
  inline ::ReturnState* release_state();
  inline void set_allocated_state(::ReturnState* state);

  // optional .tajo.client.SubmitQueryResponse.ResultType result_type = 2;
  inline bool has_result_type() const;
  inline void clear_result_type();
  static const int kResultTypeFieldNumber = 2;
  inline ::tajo::client::SubmitQueryResponse_ResultType result_type() const;
  inline void set_result_type(::tajo::client::SubmitQueryResponse_ResultType value);

  // optional .QueryIdProto queryId = 3;
  inline bool has_queryid() const;
  inline void clear_queryid();
  static const int kQueryIdFieldNumber = 3;
  inline const ::QueryIdProto& queryid() const;
  inline ::QueryIdProto* mutable_queryid();
  inline ::QueryIdProto* release_queryid();
  inline void set_allocated_queryid(::QueryIdProto* queryid);

  // optional string userName = 4;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 4;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string queryMasterHost = 6;
  inline bool has_querymasterhost() const;
  inline void clear_querymasterhost();
  static const int kQueryMasterHostFieldNumber = 6;
  inline const ::std::string& querymasterhost() const;
  inline void set_querymasterhost(const ::std::string& value);
  inline void set_querymasterhost(const char* value);
  inline void set_querymasterhost(const char* value, size_t size);
  inline ::std::string* mutable_querymasterhost();
  inline ::std::string* release_querymasterhost();
  inline void set_allocated_querymasterhost(::std::string* querymasterhost);

  // optional int32 queryMasterPort = 7;
  inline bool has_querymasterport() const;
  inline void clear_querymasterport();
  static const int kQueryMasterPortFieldNumber = 7;
  inline ::google::protobuf::int32 querymasterport() const;
  inline void set_querymasterport(::google::protobuf::int32 value);

  // optional .tajo.client.SerializedResultSet resultSet = 8;
  inline bool has_resultset() const;
  inline void clear_resultset();
  static const int kResultSetFieldNumber = 8;
  inline const ::tajo::client::SerializedResultSet& resultset() const;
  inline ::tajo::client::SerializedResultSet* mutable_resultset();
  inline ::tajo::client::SerializedResultSet* release_resultset();
  inline void set_allocated_resultset(::tajo::client::SerializedResultSet* resultset);

  // optional .TableDescProto tableDesc = 9;
  inline bool has_tabledesc() const;
  inline void clear_tabledesc();
  static const int kTableDescFieldNumber = 9;
  inline const ::TableDescProto& tabledesc() const;
  inline ::TableDescProto* mutable_tabledesc();
  inline ::TableDescProto* release_tabledesc();
  inline void set_allocated_tabledesc(::TableDescProto* tabledesc);

  // optional int32 maxRowNum = 10;
  inline bool has_maxrownum() const;
  inline void clear_maxrownum();
  static const int kMaxRowNumFieldNumber = 10;
  inline ::google::protobuf::int32 maxrownum() const;
  inline void set_maxrownum(::google::protobuf::int32 value);

  // optional .KeyValueSetProto sessionVars = 11;
  inline bool has_sessionvars() const;
  inline void clear_sessionvars();
  static const int kSessionVarsFieldNumber = 11;
  inline const ::KeyValueSetProto& sessionvars() const;
  inline ::KeyValueSetProto* mutable_sessionvars();
  inline ::KeyValueSetProto* release_sessionvars();
  inline void set_allocated_sessionvars(::KeyValueSetProto* sessionvars);

  // @@protoc_insertion_point(class_scope:tajo.client.SubmitQueryResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_result_type();
  inline void clear_has_result_type();
  inline void set_has_queryid();
  inline void clear_has_queryid();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_querymasterhost();
  inline void clear_has_querymasterhost();
  inline void set_has_querymasterport();
  inline void clear_has_querymasterport();
  inline void set_has_resultset();
  inline void clear_has_resultset();
  inline void set_has_tabledesc();
  inline void clear_has_tabledesc();
  inline void set_has_maxrownum();
  inline void clear_has_maxrownum();
  inline void set_has_sessionvars();
  inline void clear_has_sessionvars();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ReturnState* state_;
  ::QueryIdProto* queryid_;
  ::std::string* username_;
  int result_type_;
  ::google::protobuf::int32 querymasterport_;
  ::std::string* querymasterhost_;
  ::tajo::client::SerializedResultSet* resultset_;
  ::TableDescProto* tabledesc_;
  ::KeyValueSetProto* sessionvars_;
  ::google::protobuf::int32 maxrownum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static SubmitQueryResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetQueryStatusResponse : public ::google::protobuf::Message {
 public:
  GetQueryStatusResponse();
  virtual ~GetQueryStatusResponse();

  GetQueryStatusResponse(const GetQueryStatusResponse& from);

  inline GetQueryStatusResponse& operator=(const GetQueryStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetQueryStatusResponse& default_instance();

  void Swap(GetQueryStatusResponse* other);

  // implements Message ----------------------------------------------

  GetQueryStatusResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetQueryStatusResponse& from);
  void MergeFrom(const GetQueryStatusResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ReturnState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline const ::ReturnState& state() const;
  inline ::ReturnState* mutable_state();
  inline ::ReturnState* release_state();
  inline void set_allocated_state(::ReturnState* state);

  // optional .QueryIdProto queryId = 2;
  inline bool has_queryid() const;
  inline void clear_queryid();
  static const int kQueryIdFieldNumber = 2;
  inline const ::QueryIdProto& queryid() const;
  inline ::QueryIdProto* mutable_queryid();
  inline ::QueryIdProto* release_queryid();
  inline void set_allocated_queryid(::QueryIdProto* queryid);

  // optional .QueryState query_state = 3;
  inline bool has_query_state() const;
  inline void clear_query_state();
  static const int kQueryStateFieldNumber = 3;
  inline ::QueryState query_state() const;
  inline void set_query_state(::QueryState value);

  // optional float progress = 4;
  inline bool has_progress() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 4;
  inline float progress() const;
  inline void set_progress(float value);

  // optional int64 submitTime = 5;
  inline bool has_submittime() const;
  inline void clear_submittime();
  static const int kSubmitTimeFieldNumber = 5;
  inline ::google::protobuf::int64 submittime() const;
  inline void set_submittime(::google::protobuf::int64 value);

  // optional int64 finishTime = 7;
  inline bool has_finishtime() const;
  inline void clear_finishtime();
  static const int kFinishTimeFieldNumber = 7;
  inline ::google::protobuf::int64 finishtime() const;
  inline void set_finishtime(::google::protobuf::int64 value);

  // optional bool hasResult = 8;
  inline bool has_hasresult() const;
  inline void clear_hasresult();
  static const int kHasResultFieldNumber = 8;
  inline bool hasresult() const;
  inline void set_hasresult(bool value);

  // optional string errorMessage = 9;
  inline bool has_errormessage() const;
  inline void clear_errormessage();
  static const int kErrorMessageFieldNumber = 9;
  inline const ::std::string& errormessage() const;
  inline void set_errormessage(const ::std::string& value);
  inline void set_errormessage(const char* value);
  inline void set_errormessage(const char* value, size_t size);
  inline ::std::string* mutable_errormessage();
  inline ::std::string* release_errormessage();
  inline void set_allocated_errormessage(::std::string* errormessage);

  // optional string errorTrace = 10;
  inline bool has_errortrace() const;
  inline void clear_errortrace();
  static const int kErrorTraceFieldNumber = 10;
  inline const ::std::string& errortrace() const;
  inline void set_errortrace(const ::std::string& value);
  inline void set_errortrace(const char* value);
  inline void set_errortrace(const char* value, size_t size);
  inline ::std::string* mutable_errortrace();
  inline ::std::string* release_errortrace();
  inline void set_allocated_errortrace(::std::string* errortrace);

  // optional string queryMasterHost = 11;
  inline bool has_querymasterhost() const;
  inline void clear_querymasterhost();
  static const int kQueryMasterHostFieldNumber = 11;
  inline const ::std::string& querymasterhost() const;
  inline void set_querymasterhost(const ::std::string& value);
  inline void set_querymasterhost(const char* value);
  inline void set_querymasterhost(const char* value, size_t size);
  inline ::std::string* mutable_querymasterhost();
  inline ::std::string* release_querymasterhost();
  inline void set_allocated_querymasterhost(::std::string* querymasterhost);

  // optional int32 queryMasterPort = 12;
  inline bool has_querymasterport() const;
  inline void clear_querymasterport();
  static const int kQueryMasterPortFieldNumber = 12;
  inline ::google::protobuf::int32 querymasterport() const;
  inline void set_querymasterport(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tajo.client.GetQueryStatusResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_queryid();
  inline void clear_has_queryid();
  inline void set_has_query_state();
  inline void clear_has_query_state();
  inline void set_has_progress();
  inline void clear_has_progress();
  inline void set_has_submittime();
  inline void clear_has_submittime();
  inline void set_has_finishtime();
  inline void clear_has_finishtime();
  inline void set_has_hasresult();
  inline void clear_has_hasresult();
  inline void set_has_errormessage();
  inline void clear_has_errormessage();
  inline void set_has_errortrace();
  inline void clear_has_errortrace();
  inline void set_has_querymasterhost();
  inline void clear_has_querymasterhost();
  inline void set_has_querymasterport();
  inline void clear_has_querymasterport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ReturnState* state_;
  ::QueryIdProto* queryid_;
  int query_state_;
  float progress_;
  ::google::protobuf::int64 submittime_;
  ::google::protobuf::int64 finishtime_;
  ::std::string* errormessage_;
  ::std::string* errortrace_;
  bool hasresult_;
  ::google::protobuf::int32 querymasterport_;
  ::std::string* querymasterhost_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static GetQueryStatusResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetQueryResultDataRequest : public ::google::protobuf::Message {
 public:
  GetQueryResultDataRequest();
  virtual ~GetQueryResultDataRequest();

  GetQueryResultDataRequest(const GetQueryResultDataRequest& from);

  inline GetQueryResultDataRequest& operator=(const GetQueryResultDataRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetQueryResultDataRequest& default_instance();

  void Swap(GetQueryResultDataRequest* other);

  // implements Message ----------------------------------------------

  GetQueryResultDataRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetQueryResultDataRequest& from);
  void MergeFrom(const GetQueryResultDataRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .SessionIdProto sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline const ::SessionIdProto& sessionid() const;
  inline ::SessionIdProto* mutable_sessionid();
  inline ::SessionIdProto* release_sessionid();
  inline void set_allocated_sessionid(::SessionIdProto* sessionid);

  // required .QueryIdProto queryId = 2;
  inline bool has_queryid() const;
  inline void clear_queryid();
  static const int kQueryIdFieldNumber = 2;
  inline const ::QueryIdProto& queryid() const;
  inline ::QueryIdProto* mutable_queryid();
  inline ::QueryIdProto* release_queryid();
  inline void set_allocated_queryid(::QueryIdProto* queryid);

  // required int32 fetchRowNum = 3;
  inline bool has_fetchrownum() const;
  inline void clear_fetchrownum();
  static const int kFetchRowNumFieldNumber = 3;
  inline ::google::protobuf::int32 fetchrownum() const;
  inline void set_fetchrownum(::google::protobuf::int32 value);

  // optional .CodecType compressCodec = 4;
  inline bool has_compresscodec() const;
  inline void clear_compresscodec();
  static const int kCompressCodecFieldNumber = 4;
  inline ::CodecType compresscodec() const;
  inline void set_compresscodec(::CodecType value);

  // @@protoc_insertion_point(class_scope:tajo.client.GetQueryResultDataRequest)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_queryid();
  inline void clear_has_queryid();
  inline void set_has_fetchrownum();
  inline void clear_has_fetchrownum();
  inline void set_has_compresscodec();
  inline void clear_has_compresscodec();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SessionIdProto* sessionid_;
  ::QueryIdProto* queryid_;
  ::google::protobuf::int32 fetchrownum_;
  int compresscodec_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static GetQueryResultDataRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetQueryResultDataResponse : public ::google::protobuf::Message {
 public:
  GetQueryResultDataResponse();
  virtual ~GetQueryResultDataResponse();

  GetQueryResultDataResponse(const GetQueryResultDataResponse& from);

  inline GetQueryResultDataResponse& operator=(const GetQueryResultDataResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetQueryResultDataResponse& default_instance();

  void Swap(GetQueryResultDataResponse* other);

  // implements Message ----------------------------------------------

  GetQueryResultDataResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetQueryResultDataResponse& from);
  void MergeFrom(const GetQueryResultDataResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ReturnState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline const ::ReturnState& state() const;
  inline ::ReturnState* mutable_state();
  inline ::ReturnState* release_state();
  inline void set_allocated_state(::ReturnState* state);

  // optional .tajo.client.SerializedResultSet resultSet = 2;
  inline bool has_resultset() const;
  inline void clear_resultset();
  static const int kResultSetFieldNumber = 2;
  inline const ::tajo::client::SerializedResultSet& resultset() const;
  inline ::tajo::client::SerializedResultSet* mutable_resultset();
  inline ::tajo::client::SerializedResultSet* release_resultset();
  inline void set_allocated_resultset(::tajo::client::SerializedResultSet* resultset);

  // @@protoc_insertion_point(class_scope:tajo.client.GetQueryResultDataResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_resultset();
  inline void clear_has_resultset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ReturnState* state_;
  ::tajo::client::SerializedResultSet* resultset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static GetQueryResultDataResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetClusterInfoRequest : public ::google::protobuf::Message {
 public:
  GetClusterInfoRequest();
  virtual ~GetClusterInfoRequest();

  GetClusterInfoRequest(const GetClusterInfoRequest& from);

  inline GetClusterInfoRequest& operator=(const GetClusterInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetClusterInfoRequest& default_instance();

  void Swap(GetClusterInfoRequest* other);

  // implements Message ----------------------------------------------

  GetClusterInfoRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetClusterInfoRequest& from);
  void MergeFrom(const GetClusterInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SessionIdProto sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline const ::SessionIdProto& sessionid() const;
  inline ::SessionIdProto* mutable_sessionid();
  inline ::SessionIdProto* release_sessionid();
  inline void set_allocated_sessionid(::SessionIdProto* sessionid);

  // @@protoc_insertion_point(class_scope:tajo.client.GetClusterInfoRequest)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SessionIdProto* sessionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static GetClusterInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class WorkerResourceInfo : public ::google::protobuf::Message {
 public:
  WorkerResourceInfo();
  virtual ~WorkerResourceInfo();

  WorkerResourceInfo(const WorkerResourceInfo& from);

  inline WorkerResourceInfo& operator=(const WorkerResourceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WorkerResourceInfo& default_instance();

  void Swap(WorkerResourceInfo* other);

  // implements Message ----------------------------------------------

  WorkerResourceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WorkerResourceInfo& from);
  void MergeFrom(const WorkerResourceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .WorkerConnectionInfoProto connectionInfo = 1;
  inline bool has_connectioninfo() const;
  inline void clear_connectioninfo();
  static const int kConnectionInfoFieldNumber = 1;
  inline const ::WorkerConnectionInfoProto& connectioninfo() const;
  inline ::WorkerConnectionInfoProto* mutable_connectioninfo();
  inline ::WorkerConnectionInfoProto* release_connectioninfo();
  inline void set_allocated_connectioninfo(::WorkerConnectionInfoProto* connectioninfo);

  // required .NodeResourceProto totalResource = 2;
  inline bool has_totalresource() const;
  inline void clear_totalresource();
  static const int kTotalResourceFieldNumber = 2;
  inline const ::NodeResourceProto& totalresource() const;
  inline ::NodeResourceProto* mutable_totalresource();
  inline ::NodeResourceProto* release_totalresource();
  inline void set_allocated_totalresource(::NodeResourceProto* totalresource);

  // required .NodeResourceProto availableResource = 3;
  inline bool has_availableresource() const;
  inline void clear_availableresource();
  static const int kAvailableResourceFieldNumber = 3;
  inline const ::NodeResourceProto& availableresource() const;
  inline ::NodeResourceProto* mutable_availableresource();
  inline ::NodeResourceProto* release_availableresource();
  inline void set_allocated_availableresource(::NodeResourceProto* availableresource);

  // required int32 numRunningTasks = 4;
  inline bool has_numrunningtasks() const;
  inline void clear_numrunningtasks();
  static const int kNumRunningTasksFieldNumber = 4;
  inline ::google::protobuf::int32 numrunningtasks() const;
  inline void set_numrunningtasks(::google::protobuf::int32 value);

  // required string workerStatus = 5;
  inline bool has_workerstatus() const;
  inline void clear_workerstatus();
  static const int kWorkerStatusFieldNumber = 5;
  inline const ::std::string& workerstatus() const;
  inline void set_workerstatus(const ::std::string& value);
  inline void set_workerstatus(const char* value);
  inline void set_workerstatus(const char* value, size_t size);
  inline ::std::string* mutable_workerstatus();
  inline ::std::string* release_workerstatus();
  inline void set_allocated_workerstatus(::std::string* workerstatus);

  // required int64 lastHeartbeat = 6;
  inline bool has_lastheartbeat() const;
  inline void clear_lastheartbeat();
  static const int kLastHeartbeatFieldNumber = 6;
  inline ::google::protobuf::int64 lastheartbeat() const;
  inline void set_lastheartbeat(::google::protobuf::int64 value);

  // required int32 numQueryMasterTasks = 7;
  inline bool has_numquerymastertasks() const;
  inline void clear_numquerymastertasks();
  static const int kNumQueryMasterTasksFieldNumber = 7;
  inline ::google::protobuf::int32 numquerymastertasks() const;
  inline void set_numquerymastertasks(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tajo.client.WorkerResourceInfo)
 private:
  inline void set_has_connectioninfo();
  inline void clear_has_connectioninfo();
  inline void set_has_totalresource();
  inline void clear_has_totalresource();
  inline void set_has_availableresource();
  inline void clear_has_availableresource();
  inline void set_has_numrunningtasks();
  inline void clear_has_numrunningtasks();
  inline void set_has_workerstatus();
  inline void clear_has_workerstatus();
  inline void set_has_lastheartbeat();
  inline void clear_has_lastheartbeat();
  inline void set_has_numquerymastertasks();
  inline void clear_has_numquerymastertasks();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::WorkerConnectionInfoProto* connectioninfo_;
  ::NodeResourceProto* totalresource_;
  ::NodeResourceProto* availableresource_;
  ::std::string* workerstatus_;
  ::google::protobuf::int32 numrunningtasks_;
  ::google::protobuf::int32 numquerymastertasks_;
  ::google::protobuf::int64 lastheartbeat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static WorkerResourceInfo* default_instance_;
};
// -------------------------------------------------------------------

class GetClusterInfoResponse : public ::google::protobuf::Message {
 public:
  GetClusterInfoResponse();
  virtual ~GetClusterInfoResponse();

  GetClusterInfoResponse(const GetClusterInfoResponse& from);

  inline GetClusterInfoResponse& operator=(const GetClusterInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetClusterInfoResponse& default_instance();

  void Swap(GetClusterInfoResponse* other);

  // implements Message ----------------------------------------------

  GetClusterInfoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetClusterInfoResponse& from);
  void MergeFrom(const GetClusterInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ReturnState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline const ::ReturnState& state() const;
  inline ::ReturnState* mutable_state();
  inline ::ReturnState* release_state();
  inline void set_allocated_state(::ReturnState* state);

  // repeated .tajo.client.WorkerResourceInfo workerList = 2;
  inline int workerlist_size() const;
  inline void clear_workerlist();
  static const int kWorkerListFieldNumber = 2;
  inline const ::tajo::client::WorkerResourceInfo& workerlist(int index) const;
  inline ::tajo::client::WorkerResourceInfo* mutable_workerlist(int index);
  inline ::tajo::client::WorkerResourceInfo* add_workerlist();
  inline const ::google::protobuf::RepeatedPtrField< ::tajo::client::WorkerResourceInfo >&
      workerlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::tajo::client::WorkerResourceInfo >*
      mutable_workerlist();

  // @@protoc_insertion_point(class_scope:tajo.client.GetClusterInfoResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ReturnState* state_;
  ::google::protobuf::RepeatedPtrField< ::tajo::client::WorkerResourceInfo > workerlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static GetClusterInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class CreateTableRequest : public ::google::protobuf::Message {
 public:
  CreateTableRequest();
  virtual ~CreateTableRequest();

  CreateTableRequest(const CreateTableRequest& from);

  inline CreateTableRequest& operator=(const CreateTableRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateTableRequest& default_instance();

  void Swap(CreateTableRequest* other);

  // implements Message ----------------------------------------------

  CreateTableRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateTableRequest& from);
  void MergeFrom(const CreateTableRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SessionIdProto sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline const ::SessionIdProto& sessionid() const;
  inline ::SessionIdProto* mutable_sessionid();
  inline ::SessionIdProto* release_sessionid();
  inline void set_allocated_sessionid(::SessionIdProto* sessionid);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .SchemaProto schema = 3;
  inline bool has_schema() const;
  inline void clear_schema();
  static const int kSchemaFieldNumber = 3;
  inline const ::SchemaProto& schema() const;
  inline ::SchemaProto* mutable_schema();
  inline ::SchemaProto* release_schema();
  inline void set_allocated_schema(::SchemaProto* schema);

  // required .TableProto meta = 4;
  inline bool has_meta() const;
  inline void clear_meta();
  static const int kMetaFieldNumber = 4;
  inline const ::TableProto& meta() const;
  inline ::TableProto* mutable_meta();
  inline ::TableProto* release_meta();
  inline void set_allocated_meta(::TableProto* meta);

  // required string path = 5;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 5;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional .PartitionMethodProto partition = 6;
  inline bool has_partition() const;
  inline void clear_partition();
  static const int kPartitionFieldNumber = 6;
  inline const ::PartitionMethodProto& partition() const;
  inline ::PartitionMethodProto* mutable_partition();
  inline ::PartitionMethodProto* release_partition();
  inline void set_allocated_partition(::PartitionMethodProto* partition);

  // @@protoc_insertion_point(class_scope:tajo.client.CreateTableRequest)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_schema();
  inline void clear_has_schema();
  inline void set_has_meta();
  inline void clear_has_meta();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_partition();
  inline void clear_has_partition();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SessionIdProto* sessionid_;
  ::std::string* name_;
  ::SchemaProto* schema_;
  ::TableProto* meta_;
  ::std::string* path_;
  ::PartitionMethodProto* partition_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static CreateTableRequest* default_instance_;
};
// -------------------------------------------------------------------

class DropTableRequest : public ::google::protobuf::Message {
 public:
  DropTableRequest();
  virtual ~DropTableRequest();

  DropTableRequest(const DropTableRequest& from);

  inline DropTableRequest& operator=(const DropTableRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DropTableRequest& default_instance();

  void Swap(DropTableRequest* other);

  // implements Message ----------------------------------------------

  DropTableRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DropTableRequest& from);
  void MergeFrom(const DropTableRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SessionIdProto sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline const ::SessionIdProto& sessionid() const;
  inline ::SessionIdProto* mutable_sessionid();
  inline ::SessionIdProto* release_sessionid();
  inline void set_allocated_sessionid(::SessionIdProto* sessionid);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool purge = 3 [default = false];
  inline bool has_purge() const;
  inline void clear_purge();
  static const int kPurgeFieldNumber = 3;
  inline bool purge() const;
  inline void set_purge(bool value);

  // @@protoc_insertion_point(class_scope:tajo.client.DropTableRequest)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_purge();
  inline void clear_has_purge();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SessionIdProto* sessionid_;
  ::std::string* name_;
  bool purge_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static DropTableRequest* default_instance_;
};
// -------------------------------------------------------------------

class QueryInfoProto : public ::google::protobuf::Message {
 public:
  QueryInfoProto();
  virtual ~QueryInfoProto();

  QueryInfoProto(const QueryInfoProto& from);

  inline QueryInfoProto& operator=(const QueryInfoProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryInfoProto& default_instance();

  void Swap(QueryInfoProto* other);

  // implements Message ----------------------------------------------

  QueryInfoProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryInfoProto& from);
  void MergeFrom(const QueryInfoProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string queryId = 1;
  inline bool has_queryid() const;
  inline void clear_queryid();
  static const int kQueryIdFieldNumber = 1;
  inline const ::std::string& queryid() const;
  inline void set_queryid(const ::std::string& value);
  inline void set_queryid(const char* value);
  inline void set_queryid(const char* value, size_t size);
  inline ::std::string* mutable_queryid();
  inline ::std::string* release_queryid();
  inline void set_allocated_queryid(::std::string* queryid);

  // optional string sql = 2;
  inline bool has_sql() const;
  inline void clear_sql();
  static const int kSqlFieldNumber = 2;
  inline const ::std::string& sql() const;
  inline void set_sql(const ::std::string& value);
  inline void set_sql(const char* value);
  inline void set_sql(const char* value, size_t size);
  inline ::std::string* mutable_sql();
  inline ::std::string* release_sql();
  inline void set_allocated_sql(::std::string* sql);

  // optional .KeyValueSetProto contextVars = 3;
  inline bool has_contextvars() const;
  inline void clear_contextvars();
  static const int kContextVarsFieldNumber = 3;
  inline const ::KeyValueSetProto& contextvars() const;
  inline ::KeyValueSetProto* mutable_contextvars();
  inline ::KeyValueSetProto* release_contextvars();
  inline void set_allocated_contextvars(::KeyValueSetProto* contextvars);

  // optional .QueryState queryState = 4;
  inline bool has_querystate() const;
  inline void clear_querystate();
  static const int kQueryStateFieldNumber = 4;
  inline ::QueryState querystate() const;
  inline void set_querystate(::QueryState value);

  // optional float progress = 5;
  inline bool has_progress() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 5;
  inline float progress() const;
  inline void set_progress(float value);

  // optional int64 startTime = 6;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 6;
  inline ::google::protobuf::int64 starttime() const;
  inline void set_starttime(::google::protobuf::int64 value);

  // optional int64 finishTime = 7;
  inline bool has_finishtime() const;
  inline void clear_finishtime();
  static const int kFinishTimeFieldNumber = 7;
  inline ::google::protobuf::int64 finishtime() const;
  inline void set_finishtime(::google::protobuf::int64 value);

  // optional string lastMessage = 8;
  inline bool has_lastmessage() const;
  inline void clear_lastmessage();
  static const int kLastMessageFieldNumber = 8;
  inline const ::std::string& lastmessage() const;
  inline void set_lastmessage(const ::std::string& value);
  inline void set_lastmessage(const char* value);
  inline void set_lastmessage(const char* value, size_t size);
  inline ::std::string* mutable_lastmessage();
  inline ::std::string* release_lastmessage();
  inline void set_allocated_lastmessage(::std::string* lastmessage);

  // optional string hostNameOfQM = 9;
  inline bool has_hostnameofqm() const;
  inline void clear_hostnameofqm();
  static const int kHostNameOfQMFieldNumber = 9;
  inline const ::std::string& hostnameofqm() const;
  inline void set_hostnameofqm(const ::std::string& value);
  inline void set_hostnameofqm(const char* value);
  inline void set_hostnameofqm(const char* value, size_t size);
  inline ::std::string* mutable_hostnameofqm();
  inline ::std::string* release_hostnameofqm();
  inline void set_allocated_hostnameofqm(::std::string* hostnameofqm);

  // optional int32 queryMasterPort = 10;
  inline bool has_querymasterport() const;
  inline void clear_querymasterport();
  static const int kQueryMasterPortFieldNumber = 10;
  inline ::google::protobuf::int32 querymasterport() const;
  inline void set_querymasterport(::google::protobuf::int32 value);

  // optional int32 queryMasterClientPort = 11;
  inline bool has_querymasterclientport() const;
  inline void clear_querymasterclientport();
  static const int kQueryMasterClientPortFieldNumber = 11;
  inline ::google::protobuf::int32 querymasterclientport() const;
  inline void set_querymasterclientport(::google::protobuf::int32 value);

  // optional int32 queryMasterInfoPort = 12;
  inline bool has_querymasterinfoport() const;
  inline void clear_querymasterinfoport();
  static const int kQueryMasterInfoPortFieldNumber = 12;
  inline ::google::protobuf::int32 querymasterinfoport() const;
  inline void set_querymasterinfoport(::google::protobuf::int32 value);

  // optional .TableDescProto resultDesc = 13;
  inline bool has_resultdesc() const;
  inline void clear_resultdesc();
  static const int kResultDescFieldNumber = 13;
  inline const ::TableDescProto& resultdesc() const;
  inline ::TableDescProto* mutable_resultdesc();
  inline ::TableDescProto* release_resultdesc();
  inline void set_allocated_resultdesc(::TableDescProto* resultdesc);

  // @@protoc_insertion_point(class_scope:tajo.client.QueryInfoProto)
 private:
  inline void set_has_queryid();
  inline void clear_has_queryid();
  inline void set_has_sql();
  inline void clear_has_sql();
  inline void set_has_contextvars();
  inline void clear_has_contextvars();
  inline void set_has_querystate();
  inline void clear_has_querystate();
  inline void set_has_progress();
  inline void clear_has_progress();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_finishtime();
  inline void clear_has_finishtime();
  inline void set_has_lastmessage();
  inline void clear_has_lastmessage();
  inline void set_has_hostnameofqm();
  inline void clear_has_hostnameofqm();
  inline void set_has_querymasterport();
  inline void clear_has_querymasterport();
  inline void set_has_querymasterclientport();
  inline void clear_has_querymasterclientport();
  inline void set_has_querymasterinfoport();
  inline void clear_has_querymasterinfoport();
  inline void set_has_resultdesc();
  inline void clear_has_resultdesc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* queryid_;
  ::std::string* sql_;
  ::KeyValueSetProto* contextvars_;
  int querystate_;
  float progress_;
  ::google::protobuf::int64 starttime_;
  ::google::protobuf::int64 finishtime_;
  ::std::string* lastmessage_;
  ::std::string* hostnameofqm_;
  ::google::protobuf::int32 querymasterport_;
  ::google::protobuf::int32 querymasterclientport_;
  ::TableDescProto* resultdesc_;
  ::google::protobuf::int32 querymasterinfoport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static QueryInfoProto* default_instance_;
};
// -------------------------------------------------------------------

class StageHistoryProto : public ::google::protobuf::Message {
 public:
  StageHistoryProto();
  virtual ~StageHistoryProto();

  StageHistoryProto(const StageHistoryProto& from);

  inline StageHistoryProto& operator=(const StageHistoryProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StageHistoryProto& default_instance();

  void Swap(StageHistoryProto* other);

  // implements Message ----------------------------------------------

  StageHistoryProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StageHistoryProto& from);
  void MergeFrom(const StageHistoryProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string executionBlockId = 1;
  inline bool has_executionblockid() const;
  inline void clear_executionblockid();
  static const int kExecutionBlockIdFieldNumber = 1;
  inline const ::std::string& executionblockid() const;
  inline void set_executionblockid(const ::std::string& value);
  inline void set_executionblockid(const char* value);
  inline void set_executionblockid(const char* value, size_t size);
  inline ::std::string* mutable_executionblockid();
  inline ::std::string* release_executionblockid();
  inline void set_allocated_executionblockid(::std::string* executionblockid);

  // required string state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::std::string& state() const;
  inline void set_state(const ::std::string& value);
  inline void set_state(const char* value);
  inline void set_state(const char* value, size_t size);
  inline ::std::string* mutable_state();
  inline ::std::string* release_state();
  inline void set_allocated_state(::std::string* state);

  // optional int64 startTime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 3;
  inline ::google::protobuf::int64 starttime() const;
  inline void set_starttime(::google::protobuf::int64 value);

  // optional int64 finishTime = 4;
  inline bool has_finishtime() const;
  inline void clear_finishtime();
  static const int kFinishTimeFieldNumber = 4;
  inline ::google::protobuf::int64 finishtime() const;
  inline void set_finishtime(::google::protobuf::int64 value);

  // optional int32 succeededObjectCount = 5;
  inline bool has_succeededobjectcount() const;
  inline void clear_succeededobjectcount();
  static const int kSucceededObjectCountFieldNumber = 5;
  inline ::google::protobuf::int32 succeededobjectcount() const;
  inline void set_succeededobjectcount(::google::protobuf::int32 value);

  // optional int32 failedObjectCount = 6;
  inline bool has_failedobjectcount() const;
  inline void clear_failedobjectcount();
  static const int kFailedObjectCountFieldNumber = 6;
  inline ::google::protobuf::int32 failedobjectcount() const;
  inline void set_failedobjectcount(::google::protobuf::int32 value);

  // optional int32 killedObjectCount = 7;
  inline bool has_killedobjectcount() const;
  inline void clear_killedobjectcount();
  static const int kKilledObjectCountFieldNumber = 7;
  inline ::google::protobuf::int32 killedobjectcount() const;
  inline void set_killedobjectcount(::google::protobuf::int32 value);

  // optional int32 totalScheduledObjectsCount = 8;
  inline bool has_totalscheduledobjectscount() const;
  inline void clear_totalscheduledobjectscount();
  static const int kTotalScheduledObjectsCountFieldNumber = 8;
  inline ::google::protobuf::int32 totalscheduledobjectscount() const;
  inline void set_totalscheduledobjectscount(::google::protobuf::int32 value);

  // optional int64 totalInputBytes = 9;
  inline bool has_totalinputbytes() const;
  inline void clear_totalinputbytes();
  static const int kTotalInputBytesFieldNumber = 9;
  inline ::google::protobuf::int64 totalinputbytes() const;
  inline void set_totalinputbytes(::google::protobuf::int64 value);

  // optional int64 totalReadBytes = 10;
  inline bool has_totalreadbytes() const;
  inline void clear_totalreadbytes();
  static const int kTotalReadBytesFieldNumber = 10;
  inline ::google::protobuf::int64 totalreadbytes() const;
  inline void set_totalreadbytes(::google::protobuf::int64 value);

  // optional int64 totalReadRows = 11;
  inline bool has_totalreadrows() const;
  inline void clear_totalreadrows();
  static const int kTotalReadRowsFieldNumber = 11;
  inline ::google::protobuf::int64 totalreadrows() const;
  inline void set_totalreadrows(::google::protobuf::int64 value);

  // optional int64 totalWriteBytes = 12;
  inline bool has_totalwritebytes() const;
  inline void clear_totalwritebytes();
  static const int kTotalWriteBytesFieldNumber = 12;
  inline ::google::protobuf::int64 totalwritebytes() const;
  inline void set_totalwritebytes(::google::protobuf::int64 value);

  // optional int64 totalWriteRows = 13;
  inline bool has_totalwriterows() const;
  inline void clear_totalwriterows();
  static const int kTotalWriteRowsFieldNumber = 13;
  inline ::google::protobuf::int64 totalwriterows() const;
  inline void set_totalwriterows(::google::protobuf::int64 value);

  // optional int32 numShuffles = 14;
  inline bool has_numshuffles() const;
  inline void clear_numshuffles();
  static const int kNumShufflesFieldNumber = 14;
  inline ::google::protobuf::int32 numshuffles() const;
  inline void set_numshuffles(::google::protobuf::int32 value);

  // optional float progress = 15;
  inline bool has_progress() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 15;
  inline float progress() const;
  inline void set_progress(float value);

  // optional string plan = 16;
  inline bool has_plan() const;
  inline void clear_plan();
  static const int kPlanFieldNumber = 16;
  inline const ::std::string& plan() const;
  inline void set_plan(const ::std::string& value);
  inline void set_plan(const char* value);
  inline void set_plan(const char* value, size_t size);
  inline ::std::string* mutable_plan();
  inline ::std::string* release_plan();
  inline void set_allocated_plan(::std::string* plan);

  // optional int32 hostLocalAssigned = 17;
  inline bool has_hostlocalassigned() const;
  inline void clear_hostlocalassigned();
  static const int kHostLocalAssignedFieldNumber = 17;
  inline ::google::protobuf::int32 hostlocalassigned() const;
  inline void set_hostlocalassigned(::google::protobuf::int32 value);

  // optional int32 rackLocalAssigned = 18;
  inline bool has_racklocalassigned() const;
  inline void clear_racklocalassigned();
  static const int kRackLocalAssignedFieldNumber = 18;
  inline ::google::protobuf::int32 racklocalassigned() const;
  inline void set_racklocalassigned(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tajo.client.StageHistoryProto)
 private:
  inline void set_has_executionblockid();
  inline void clear_has_executionblockid();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_finishtime();
  inline void clear_has_finishtime();
  inline void set_has_succeededobjectcount();
  inline void clear_has_succeededobjectcount();
  inline void set_has_failedobjectcount();
  inline void clear_has_failedobjectcount();
  inline void set_has_killedobjectcount();
  inline void clear_has_killedobjectcount();
  inline void set_has_totalscheduledobjectscount();
  inline void clear_has_totalscheduledobjectscount();
  inline void set_has_totalinputbytes();
  inline void clear_has_totalinputbytes();
  inline void set_has_totalreadbytes();
  inline void clear_has_totalreadbytes();
  inline void set_has_totalreadrows();
  inline void clear_has_totalreadrows();
  inline void set_has_totalwritebytes();
  inline void clear_has_totalwritebytes();
  inline void set_has_totalwriterows();
  inline void clear_has_totalwriterows();
  inline void set_has_numshuffles();
  inline void clear_has_numshuffles();
  inline void set_has_progress();
  inline void clear_has_progress();
  inline void set_has_plan();
  inline void clear_has_plan();
  inline void set_has_hostlocalassigned();
  inline void clear_has_hostlocalassigned();
  inline void set_has_racklocalassigned();
  inline void clear_has_racklocalassigned();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* executionblockid_;
  ::std::string* state_;
  ::google::protobuf::int64 starttime_;
  ::google::protobuf::int64 finishtime_;
  ::google::protobuf::int32 succeededobjectcount_;
  ::google::protobuf::int32 failedobjectcount_;
  ::google::protobuf::int32 killedobjectcount_;
  ::google::protobuf::int32 totalscheduledobjectscount_;
  ::google::protobuf::int64 totalinputbytes_;
  ::google::protobuf::int64 totalreadbytes_;
  ::google::protobuf::int64 totalreadrows_;
  ::google::protobuf::int64 totalwritebytes_;
  ::google::protobuf::int64 totalwriterows_;
  ::google::protobuf::int32 numshuffles_;
  float progress_;
  ::std::string* plan_;
  ::google::protobuf::int32 hostlocalassigned_;
  ::google::protobuf::int32 racklocalassigned_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static StageHistoryProto* default_instance_;
};
// -------------------------------------------------------------------

class QueryHistoryProto : public ::google::protobuf::Message {
 public:
  QueryHistoryProto();
  virtual ~QueryHistoryProto();

  QueryHistoryProto(const QueryHistoryProto& from);

  inline QueryHistoryProto& operator=(const QueryHistoryProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryHistoryProto& default_instance();

  void Swap(QueryHistoryProto* other);

  // implements Message ----------------------------------------------

  QueryHistoryProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryHistoryProto& from);
  void MergeFrom(const QueryHistoryProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string queryId = 1;
  inline bool has_queryid() const;
  inline void clear_queryid();
  static const int kQueryIdFieldNumber = 1;
  inline const ::std::string& queryid() const;
  inline void set_queryid(const ::std::string& value);
  inline void set_queryid(const char* value);
  inline void set_queryid(const char* value, size_t size);
  inline ::std::string* mutable_queryid();
  inline ::std::string* release_queryid();
  inline void set_allocated_queryid(::std::string* queryid);

  // optional string queryMaster = 2;
  inline bool has_querymaster() const;
  inline void clear_querymaster();
  static const int kQueryMasterFieldNumber = 2;
  inline const ::std::string& querymaster() const;
  inline void set_querymaster(const ::std::string& value);
  inline void set_querymaster(const char* value);
  inline void set_querymaster(const char* value, size_t size);
  inline ::std::string* mutable_querymaster();
  inline ::std::string* release_querymaster();
  inline void set_allocated_querymaster(::std::string* querymaster);

  // optional int32 httpPort = 3;
  inline bool has_httpport() const;
  inline void clear_httpport();
  static const int kHttpPortFieldNumber = 3;
  inline ::google::protobuf::int32 httpport() const;
  inline void set_httpport(::google::protobuf::int32 value);

  // optional string logicalPlan = 4;
  inline bool has_logicalplan() const;
  inline void clear_logicalplan();
  static const int kLogicalPlanFieldNumber = 4;
  inline const ::std::string& logicalplan() const;
  inline void set_logicalplan(const ::std::string& value);
  inline void set_logicalplan(const char* value);
  inline void set_logicalplan(const char* value, size_t size);
  inline ::std::string* mutable_logicalplan();
  inline ::std::string* release_logicalplan();
  inline void set_allocated_logicalplan(::std::string* logicalplan);

  // optional string distributedPlan = 5;
  inline bool has_distributedplan() const;
  inline void clear_distributedplan();
  static const int kDistributedPlanFieldNumber = 5;
  inline const ::std::string& distributedplan() const;
  inline void set_distributedplan(const ::std::string& value);
  inline void set_distributedplan(const char* value);
  inline void set_distributedplan(const char* value, size_t size);
  inline ::std::string* mutable_distributedplan();
  inline ::std::string* release_distributedplan();
  inline void set_allocated_distributedplan(::std::string* distributedplan);

  // repeated .KeyValueProto sessionVariables = 6;
  inline int sessionvariables_size() const;
  inline void clear_sessionvariables();
  static const int kSessionVariablesFieldNumber = 6;
  inline const ::KeyValueProto& sessionvariables(int index) const;
  inline ::KeyValueProto* mutable_sessionvariables(int index);
  inline ::KeyValueProto* add_sessionvariables();
  inline const ::google::protobuf::RepeatedPtrField< ::KeyValueProto >&
      sessionvariables() const;
  inline ::google::protobuf::RepeatedPtrField< ::KeyValueProto >*
      mutable_sessionvariables();

  // repeated .tajo.client.StageHistoryProto stageHistories = 7;
  inline int stagehistories_size() const;
  inline void clear_stagehistories();
  static const int kStageHistoriesFieldNumber = 7;
  inline const ::tajo::client::StageHistoryProto& stagehistories(int index) const;
  inline ::tajo::client::StageHistoryProto* mutable_stagehistories(int index);
  inline ::tajo::client::StageHistoryProto* add_stagehistories();
  inline const ::google::protobuf::RepeatedPtrField< ::tajo::client::StageHistoryProto >&
      stagehistories() const;
  inline ::google::protobuf::RepeatedPtrField< ::tajo::client::StageHistoryProto >*
      mutable_stagehistories();

  // @@protoc_insertion_point(class_scope:tajo.client.QueryHistoryProto)
 private:
  inline void set_has_queryid();
  inline void clear_has_queryid();
  inline void set_has_querymaster();
  inline void clear_has_querymaster();
  inline void set_has_httpport();
  inline void clear_has_httpport();
  inline void set_has_logicalplan();
  inline void clear_has_logicalplan();
  inline void set_has_distributedplan();
  inline void clear_has_distributedplan();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* queryid_;
  ::std::string* querymaster_;
  ::std::string* logicalplan_;
  ::std::string* distributedplan_;
  ::google::protobuf::RepeatedPtrField< ::KeyValueProto > sessionvariables_;
  ::google::protobuf::RepeatedPtrField< ::tajo::client::StageHistoryProto > stagehistories_;
  ::google::protobuf::int32 httpport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static QueryHistoryProto* default_instance_;
};
// -------------------------------------------------------------------

class GetQueryHistoryResponse : public ::google::protobuf::Message {
 public:
  GetQueryHistoryResponse();
  virtual ~GetQueryHistoryResponse();

  GetQueryHistoryResponse(const GetQueryHistoryResponse& from);

  inline GetQueryHistoryResponse& operator=(const GetQueryHistoryResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetQueryHistoryResponse& default_instance();

  void Swap(GetQueryHistoryResponse* other);

  // implements Message ----------------------------------------------

  GetQueryHistoryResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetQueryHistoryResponse& from);
  void MergeFrom(const GetQueryHistoryResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ReturnState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline const ::ReturnState& state() const;
  inline ::ReturnState* mutable_state();
  inline ::ReturnState* release_state();
  inline void set_allocated_state(::ReturnState* state);

  // optional .tajo.client.QueryHistoryProto queryHistory = 2;
  inline bool has_queryhistory() const;
  inline void clear_queryhistory();
  static const int kQueryHistoryFieldNumber = 2;
  inline const ::tajo::client::QueryHistoryProto& queryhistory() const;
  inline ::tajo::client::QueryHistoryProto* mutable_queryhistory();
  inline ::tajo::client::QueryHistoryProto* release_queryhistory();
  inline void set_allocated_queryhistory(::tajo::client::QueryHistoryProto* queryhistory);

  // @@protoc_insertion_point(class_scope:tajo.client.GetQueryHistoryResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_queryhistory();
  inline void clear_has_queryhistory();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ReturnState* state_;
  ::tajo::client::QueryHistoryProto* queryhistory_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static GetQueryHistoryResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetQueryInfoResponse : public ::google::protobuf::Message {
 public:
  GetQueryInfoResponse();
  virtual ~GetQueryInfoResponse();

  GetQueryInfoResponse(const GetQueryInfoResponse& from);

  inline GetQueryInfoResponse& operator=(const GetQueryInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetQueryInfoResponse& default_instance();

  void Swap(GetQueryInfoResponse* other);

  // implements Message ----------------------------------------------

  GetQueryInfoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetQueryInfoResponse& from);
  void MergeFrom(const GetQueryInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ReturnState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline const ::ReturnState& state() const;
  inline ::ReturnState* mutable_state();
  inline ::ReturnState* release_state();
  inline void set_allocated_state(::ReturnState* state);

  // optional .tajo.client.QueryInfoProto queryInfo = 2;
  inline bool has_queryinfo() const;
  inline void clear_queryinfo();
  static const int kQueryInfoFieldNumber = 2;
  inline const ::tajo::client::QueryInfoProto& queryinfo() const;
  inline ::tajo::client::QueryInfoProto* mutable_queryinfo();
  inline ::tajo::client::QueryInfoProto* release_queryinfo();
  inline void set_allocated_queryinfo(::tajo::client::QueryInfoProto* queryinfo);

  // @@protoc_insertion_point(class_scope:tajo.client.GetQueryInfoResponse)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_queryinfo();
  inline void clear_has_queryinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ReturnState* state_;
  ::tajo::client::QueryInfoProto* queryinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static GetQueryInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class CreateIndexResponse : public ::google::protobuf::Message {
 public:
  CreateIndexResponse();
  virtual ~CreateIndexResponse();

  CreateIndexResponse(const CreateIndexResponse& from);

  inline CreateIndexResponse& operator=(const CreateIndexResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateIndexResponse& default_instance();

  void Swap(CreateIndexResponse* other);

  // implements Message ----------------------------------------------

  CreateIndexResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateIndexResponse& from);
  void MergeFrom(const CreateIndexResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ReturnState result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ReturnState& result() const;
  inline ::ReturnState* mutable_result();
  inline ::ReturnState* release_result();
  inline void set_allocated_result(::ReturnState* result);

  // optional .IndexDescProto indexDesc = 2;
  inline bool has_indexdesc() const;
  inline void clear_indexdesc();
  static const int kIndexDescFieldNumber = 2;
  inline const ::IndexDescProto& indexdesc() const;
  inline ::IndexDescProto* mutable_indexdesc();
  inline ::IndexDescProto* release_indexdesc();
  inline void set_allocated_indexdesc(::IndexDescProto* indexdesc);

  // @@protoc_insertion_point(class_scope:tajo.client.CreateIndexResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_indexdesc();
  inline void clear_has_indexdesc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ReturnState* result_;
  ::IndexDescProto* indexdesc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static CreateIndexResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetIndexWithColumnsRequest : public ::google::protobuf::Message {
 public:
  GetIndexWithColumnsRequest();
  virtual ~GetIndexWithColumnsRequest();

  GetIndexWithColumnsRequest(const GetIndexWithColumnsRequest& from);

  inline GetIndexWithColumnsRequest& operator=(const GetIndexWithColumnsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetIndexWithColumnsRequest& default_instance();

  void Swap(GetIndexWithColumnsRequest* other);

  // implements Message ----------------------------------------------

  GetIndexWithColumnsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetIndexWithColumnsRequest& from);
  void MergeFrom(const GetIndexWithColumnsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .SessionIdProto sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline const ::SessionIdProto& sessionid() const;
  inline ::SessionIdProto* mutable_sessionid();
  inline ::SessionIdProto* release_sessionid();
  inline void set_allocated_sessionid(::SessionIdProto* sessionid);

  // required string tableName = 2;
  inline bool has_tablename() const;
  inline void clear_tablename();
  static const int kTableNameFieldNumber = 2;
  inline const ::std::string& tablename() const;
  inline void set_tablename(const ::std::string& value);
  inline void set_tablename(const char* value);
  inline void set_tablename(const char* value, size_t size);
  inline ::std::string* mutable_tablename();
  inline ::std::string* release_tablename();
  inline void set_allocated_tablename(::std::string* tablename);

  // repeated string columnNames = 3;
  inline int columnnames_size() const;
  inline void clear_columnnames();
  static const int kColumnNamesFieldNumber = 3;
  inline const ::std::string& columnnames(int index) const;
  inline ::std::string* mutable_columnnames(int index);
  inline void set_columnnames(int index, const ::std::string& value);
  inline void set_columnnames(int index, const char* value);
  inline void set_columnnames(int index, const char* value, size_t size);
  inline ::std::string* add_columnnames();
  inline void add_columnnames(const ::std::string& value);
  inline void add_columnnames(const char* value);
  inline void add_columnnames(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& columnnames() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_columnnames();

  // @@protoc_insertion_point(class_scope:tajo.client.GetIndexWithColumnsRequest)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_tablename();
  inline void clear_has_tablename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::SessionIdProto* sessionid_;
  ::std::string* tablename_;
  ::google::protobuf::RepeatedPtrField< ::std::string> columnnames_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ClientProtos_2eproto();
  friend void protobuf_AssignDesc_ClientProtos_2eproto();
  friend void protobuf_ShutdownFile_ClientProtos_2eproto();

  void InitAsDefaultInstance();
  static GetIndexWithColumnsRequest* default_instance_;
};
// ===================================================================


// ===================================================================

// CreateSessionRequest

// required string username = 1;
inline bool CreateSessionRequest::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateSessionRequest::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateSessionRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateSessionRequest::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& CreateSessionRequest::username() const {
  return *username_;
}
inline void CreateSessionRequest::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void CreateSessionRequest::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void CreateSessionRequest::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateSessionRequest::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* CreateSessionRequest::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateSessionRequest::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string baseDatabaseName = 2;
inline bool CreateSessionRequest::has_basedatabasename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateSessionRequest::set_has_basedatabasename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateSessionRequest::clear_has_basedatabasename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateSessionRequest::clear_basedatabasename() {
  if (basedatabasename_ != &::google::protobuf::internal::kEmptyString) {
    basedatabasename_->clear();
  }
  clear_has_basedatabasename();
}
inline const ::std::string& CreateSessionRequest::basedatabasename() const {
  return *basedatabasename_;
}
inline void CreateSessionRequest::set_basedatabasename(const ::std::string& value) {
  set_has_basedatabasename();
  if (basedatabasename_ == &::google::protobuf::internal::kEmptyString) {
    basedatabasename_ = new ::std::string;
  }
  basedatabasename_->assign(value);
}
inline void CreateSessionRequest::set_basedatabasename(const char* value) {
  set_has_basedatabasename();
  if (basedatabasename_ == &::google::protobuf::internal::kEmptyString) {
    basedatabasename_ = new ::std::string;
  }
  basedatabasename_->assign(value);
}
inline void CreateSessionRequest::set_basedatabasename(const char* value, size_t size) {
  set_has_basedatabasename();
  if (basedatabasename_ == &::google::protobuf::internal::kEmptyString) {
    basedatabasename_ = new ::std::string;
  }
  basedatabasename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateSessionRequest::mutable_basedatabasename() {
  set_has_basedatabasename();
  if (basedatabasename_ == &::google::protobuf::internal::kEmptyString) {
    basedatabasename_ = new ::std::string;
  }
  return basedatabasename_;
}
inline ::std::string* CreateSessionRequest::release_basedatabasename() {
  clear_has_basedatabasename();
  if (basedatabasename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = basedatabasename_;
    basedatabasename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateSessionRequest::set_allocated_basedatabasename(::std::string* basedatabasename) {
  if (basedatabasename_ != &::google::protobuf::internal::kEmptyString) {
    delete basedatabasename_;
  }
  if (basedatabasename) {
    set_has_basedatabasename();
    basedatabasename_ = basedatabasename;
  } else {
    clear_has_basedatabasename();
    basedatabasename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CreateSessionResponse

// required .ReturnState state = 1;
inline bool CreateSessionResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateSessionResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateSessionResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateSessionResponse::clear_state() {
  if (state_ != NULL) state_->::ReturnState::Clear();
  clear_has_state();
}
inline const ::ReturnState& CreateSessionResponse::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::ReturnState* CreateSessionResponse::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::ReturnState;
  return state_;
}
inline ::ReturnState* CreateSessionResponse::release_state() {
  clear_has_state();
  ::ReturnState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void CreateSessionResponse::set_allocated_state(::ReturnState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// optional .SessionIdProto sessionId = 2;
inline bool CreateSessionResponse::has_sessionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateSessionResponse::set_has_sessionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateSessionResponse::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateSessionResponse::clear_sessionid() {
  if (sessionid_ != NULL) sessionid_->::SessionIdProto::Clear();
  clear_has_sessionid();
}
inline const ::SessionIdProto& CreateSessionResponse::sessionid() const {
  return sessionid_ != NULL ? *sessionid_ : *default_instance_->sessionid_;
}
inline ::SessionIdProto* CreateSessionResponse::mutable_sessionid() {
  set_has_sessionid();
  if (sessionid_ == NULL) sessionid_ = new ::SessionIdProto;
  return sessionid_;
}
inline ::SessionIdProto* CreateSessionResponse::release_sessionid() {
  clear_has_sessionid();
  ::SessionIdProto* temp = sessionid_;
  sessionid_ = NULL;
  return temp;
}
inline void CreateSessionResponse::set_allocated_sessionid(::SessionIdProto* sessionid) {
  delete sessionid_;
  sessionid_ = sessionid;
  if (sessionid) {
    set_has_sessionid();
  } else {
    clear_has_sessionid();
  }
}

// optional .KeyValueSetProto sessionVars = 3;
inline bool CreateSessionResponse::has_sessionvars() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateSessionResponse::set_has_sessionvars() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateSessionResponse::clear_has_sessionvars() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateSessionResponse::clear_sessionvars() {
  if (sessionvars_ != NULL) sessionvars_->::KeyValueSetProto::Clear();
  clear_has_sessionvars();
}
inline const ::KeyValueSetProto& CreateSessionResponse::sessionvars() const {
  return sessionvars_ != NULL ? *sessionvars_ : *default_instance_->sessionvars_;
}
inline ::KeyValueSetProto* CreateSessionResponse::mutable_sessionvars() {
  set_has_sessionvars();
  if (sessionvars_ == NULL) sessionvars_ = new ::KeyValueSetProto;
  return sessionvars_;
}
inline ::KeyValueSetProto* CreateSessionResponse::release_sessionvars() {
  clear_has_sessionvars();
  ::KeyValueSetProto* temp = sessionvars_;
  sessionvars_ = NULL;
  return temp;
}
inline void CreateSessionResponse::set_allocated_sessionvars(::KeyValueSetProto* sessionvars) {
  delete sessionvars_;
  sessionvars_ = sessionvars;
  if (sessionvars) {
    set_has_sessionvars();
  } else {
    clear_has_sessionvars();
  }
}

// -------------------------------------------------------------------

// UpdateSessionVariableRequest

// optional .SessionIdProto sessionId = 1;
inline bool UpdateSessionVariableRequest::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateSessionVariableRequest::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateSessionVariableRequest::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateSessionVariableRequest::clear_sessionid() {
  if (sessionid_ != NULL) sessionid_->::SessionIdProto::Clear();
  clear_has_sessionid();
}
inline const ::SessionIdProto& UpdateSessionVariableRequest::sessionid() const {
  return sessionid_ != NULL ? *sessionid_ : *default_instance_->sessionid_;
}
inline ::SessionIdProto* UpdateSessionVariableRequest::mutable_sessionid() {
  set_has_sessionid();
  if (sessionid_ == NULL) sessionid_ = new ::SessionIdProto;
  return sessionid_;
}
inline ::SessionIdProto* UpdateSessionVariableRequest::release_sessionid() {
  clear_has_sessionid();
  ::SessionIdProto* temp = sessionid_;
  sessionid_ = NULL;
  return temp;
}
inline void UpdateSessionVariableRequest::set_allocated_sessionid(::SessionIdProto* sessionid) {
  delete sessionid_;
  sessionid_ = sessionid;
  if (sessionid) {
    set_has_sessionid();
  } else {
    clear_has_sessionid();
  }
}

// optional .KeyValueSetProto sessionVars = 2;
inline bool UpdateSessionVariableRequest::has_sessionvars() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateSessionVariableRequest::set_has_sessionvars() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateSessionVariableRequest::clear_has_sessionvars() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateSessionVariableRequest::clear_sessionvars() {
  if (sessionvars_ != NULL) sessionvars_->::KeyValueSetProto::Clear();
  clear_has_sessionvars();
}
inline const ::KeyValueSetProto& UpdateSessionVariableRequest::sessionvars() const {
  return sessionvars_ != NULL ? *sessionvars_ : *default_instance_->sessionvars_;
}
inline ::KeyValueSetProto* UpdateSessionVariableRequest::mutable_sessionvars() {
  set_has_sessionvars();
  if (sessionvars_ == NULL) sessionvars_ = new ::KeyValueSetProto;
  return sessionvars_;
}
inline ::KeyValueSetProto* UpdateSessionVariableRequest::release_sessionvars() {
  clear_has_sessionvars();
  ::KeyValueSetProto* temp = sessionvars_;
  sessionvars_ = NULL;
  return temp;
}
inline void UpdateSessionVariableRequest::set_allocated_sessionvars(::KeyValueSetProto* sessionvars) {
  delete sessionvars_;
  sessionvars_ = sessionvars;
  if (sessionvars) {
    set_has_sessionvars();
  } else {
    clear_has_sessionvars();
  }
}

// repeated string unsetVariables = 3;
inline int UpdateSessionVariableRequest::unsetvariables_size() const {
  return unsetvariables_.size();
}
inline void UpdateSessionVariableRequest::clear_unsetvariables() {
  unsetvariables_.Clear();
}
inline const ::std::string& UpdateSessionVariableRequest::unsetvariables(int index) const {
  return unsetvariables_.Get(index);
}
inline ::std::string* UpdateSessionVariableRequest::mutable_unsetvariables(int index) {
  return unsetvariables_.Mutable(index);
}
inline void UpdateSessionVariableRequest::set_unsetvariables(int index, const ::std::string& value) {
  unsetvariables_.Mutable(index)->assign(value);
}
inline void UpdateSessionVariableRequest::set_unsetvariables(int index, const char* value) {
  unsetvariables_.Mutable(index)->assign(value);
}
inline void UpdateSessionVariableRequest::set_unsetvariables(int index, const char* value, size_t size) {
  unsetvariables_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateSessionVariableRequest::add_unsetvariables() {
  return unsetvariables_.Add();
}
inline void UpdateSessionVariableRequest::add_unsetvariables(const ::std::string& value) {
  unsetvariables_.Add()->assign(value);
}
inline void UpdateSessionVariableRequest::add_unsetvariables(const char* value) {
  unsetvariables_.Add()->assign(value);
}
inline void UpdateSessionVariableRequest::add_unsetvariables(const char* value, size_t size) {
  unsetvariables_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UpdateSessionVariableRequest::unsetvariables() const {
  return unsetvariables_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UpdateSessionVariableRequest::mutable_unsetvariables() {
  return &unsetvariables_;
}

// -------------------------------------------------------------------

// SessionUpdateResponse

// required .ReturnState state = 1;
inline bool SessionUpdateResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionUpdateResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionUpdateResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionUpdateResponse::clear_state() {
  if (state_ != NULL) state_->::ReturnState::Clear();
  clear_has_state();
}
inline const ::ReturnState& SessionUpdateResponse::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::ReturnState* SessionUpdateResponse::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::ReturnState;
  return state_;
}
inline ::ReturnState* SessionUpdateResponse::release_state() {
  clear_has_state();
  ::ReturnState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void SessionUpdateResponse::set_allocated_state(::ReturnState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// optional .KeyValueSetProto sessionVars = 2;
inline bool SessionUpdateResponse::has_sessionvars() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionUpdateResponse::set_has_sessionvars() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionUpdateResponse::clear_has_sessionvars() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionUpdateResponse::clear_sessionvars() {
  if (sessionvars_ != NULL) sessionvars_->::KeyValueSetProto::Clear();
  clear_has_sessionvars();
}
inline const ::KeyValueSetProto& SessionUpdateResponse::sessionvars() const {
  return sessionvars_ != NULL ? *sessionvars_ : *default_instance_->sessionvars_;
}
inline ::KeyValueSetProto* SessionUpdateResponse::mutable_sessionvars() {
  set_has_sessionvars();
  if (sessionvars_ == NULL) sessionvars_ = new ::KeyValueSetProto;
  return sessionvars_;
}
inline ::KeyValueSetProto* SessionUpdateResponse::release_sessionvars() {
  clear_has_sessionvars();
  ::KeyValueSetProto* temp = sessionvars_;
  sessionvars_ = NULL;
  return temp;
}
inline void SessionUpdateResponse::set_allocated_sessionvars(::KeyValueSetProto* sessionvars) {
  delete sessionvars_;
  sessionvars_ = sessionvars;
  if (sessionvars) {
    set_has_sessionvars();
  } else {
    clear_has_sessionvars();
  }
}

// -------------------------------------------------------------------

// SessionedStringProto

// optional .SessionIdProto sessionId = 1;
inline bool SessionedStringProto::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionedStringProto::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionedStringProto::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionedStringProto::clear_sessionid() {
  if (sessionid_ != NULL) sessionid_->::SessionIdProto::Clear();
  clear_has_sessionid();
}
inline const ::SessionIdProto& SessionedStringProto::sessionid() const {
  return sessionid_ != NULL ? *sessionid_ : *default_instance_->sessionid_;
}
inline ::SessionIdProto* SessionedStringProto::mutable_sessionid() {
  set_has_sessionid();
  if (sessionid_ == NULL) sessionid_ = new ::SessionIdProto;
  return sessionid_;
}
inline ::SessionIdProto* SessionedStringProto::release_sessionid() {
  clear_has_sessionid();
  ::SessionIdProto* temp = sessionid_;
  sessionid_ = NULL;
  return temp;
}
inline void SessionedStringProto::set_allocated_sessionid(::SessionIdProto* sessionid) {
  delete sessionid_;
  sessionid_ = sessionid;
  if (sessionid) {
    set_has_sessionid();
  } else {
    clear_has_sessionid();
  }
}

// optional string value = 2;
inline bool SessionedStringProto::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionedStringProto::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionedStringProto::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionedStringProto::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& SessionedStringProto::value() const {
  return *value_;
}
inline void SessionedStringProto::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void SessionedStringProto::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void SessionedStringProto::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionedStringProto::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* SessionedStringProto::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionedStringProto::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ExplainQueryResponse

// required .ReturnState state = 1;
inline bool ExplainQueryResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExplainQueryResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExplainQueryResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExplainQueryResponse::clear_state() {
  if (state_ != NULL) state_->::ReturnState::Clear();
  clear_has_state();
}
inline const ::ReturnState& ExplainQueryResponse::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::ReturnState* ExplainQueryResponse::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::ReturnState;
  return state_;
}
inline ::ReturnState* ExplainQueryResponse::release_state() {
  clear_has_state();
  ::ReturnState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void ExplainQueryResponse::set_allocated_state(::ReturnState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// optional string explain = 2;
inline bool ExplainQueryResponse::has_explain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExplainQueryResponse::set_has_explain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExplainQueryResponse::clear_has_explain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExplainQueryResponse::clear_explain() {
  if (explain_ != &::google::protobuf::internal::kEmptyString) {
    explain_->clear();
  }
  clear_has_explain();
}
inline const ::std::string& ExplainQueryResponse::explain() const {
  return *explain_;
}
inline void ExplainQueryResponse::set_explain(const ::std::string& value) {
  set_has_explain();
  if (explain_ == &::google::protobuf::internal::kEmptyString) {
    explain_ = new ::std::string;
  }
  explain_->assign(value);
}
inline void ExplainQueryResponse::set_explain(const char* value) {
  set_has_explain();
  if (explain_ == &::google::protobuf::internal::kEmptyString) {
    explain_ = new ::std::string;
  }
  explain_->assign(value);
}
inline void ExplainQueryResponse::set_explain(const char* value, size_t size) {
  set_has_explain();
  if (explain_ == &::google::protobuf::internal::kEmptyString) {
    explain_ = new ::std::string;
  }
  explain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExplainQueryResponse::mutable_explain() {
  set_has_explain();
  if (explain_ == &::google::protobuf::internal::kEmptyString) {
    explain_ = new ::std::string;
  }
  return explain_;
}
inline ::std::string* ExplainQueryResponse::release_explain() {
  clear_has_explain();
  if (explain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = explain_;
    explain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExplainQueryResponse::set_allocated_explain(::std::string* explain) {
  if (explain_ != &::google::protobuf::internal::kEmptyString) {
    delete explain_;
  }
  if (explain) {
    set_has_explain();
    explain_ = explain;
  } else {
    clear_has_explain();
    explain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// QueryRequest

// optional .SessionIdProto sessionId = 1;
inline bool QueryRequest::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryRequest::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryRequest::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryRequest::clear_sessionid() {
  if (sessionid_ != NULL) sessionid_->::SessionIdProto::Clear();
  clear_has_sessionid();
}
inline const ::SessionIdProto& QueryRequest::sessionid() const {
  return sessionid_ != NULL ? *sessionid_ : *default_instance_->sessionid_;
}
inline ::SessionIdProto* QueryRequest::mutable_sessionid() {
  set_has_sessionid();
  if (sessionid_ == NULL) sessionid_ = new ::SessionIdProto;
  return sessionid_;
}
inline ::SessionIdProto* QueryRequest::release_sessionid() {
  clear_has_sessionid();
  ::SessionIdProto* temp = sessionid_;
  sessionid_ = NULL;
  return temp;
}
inline void QueryRequest::set_allocated_sessionid(::SessionIdProto* sessionid) {
  delete sessionid_;
  sessionid_ = sessionid;
  if (sessionid) {
    set_has_sessionid();
  } else {
    clear_has_sessionid();
  }
}

// required string query = 2;
inline bool QueryRequest::has_query() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryRequest::set_has_query() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryRequest::clear_has_query() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryRequest::clear_query() {
  if (query_ != &::google::protobuf::internal::kEmptyString) {
    query_->clear();
  }
  clear_has_query();
}
inline const ::std::string& QueryRequest::query() const {
  return *query_;
}
inline void QueryRequest::set_query(const ::std::string& value) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(value);
}
inline void QueryRequest::set_query(const char* value) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(value);
}
inline void QueryRequest::set_query(const char* value, size_t size) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryRequest::mutable_query() {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  return query_;
}
inline ::std::string* QueryRequest::release_query() {
  clear_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = query_;
    query_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryRequest::set_allocated_query(::std::string* query) {
  if (query_ != &::google::protobuf::internal::kEmptyString) {
    delete query_;
  }
  if (query) {
    set_has_query();
    query_ = query;
  } else {
    clear_has_query();
    query_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .KeyValueProto sessionVars = 3;
inline int QueryRequest::sessionvars_size() const {
  return sessionvars_.size();
}
inline void QueryRequest::clear_sessionvars() {
  sessionvars_.Clear();
}
inline const ::KeyValueProto& QueryRequest::sessionvars(int index) const {
  return sessionvars_.Get(index);
}
inline ::KeyValueProto* QueryRequest::mutable_sessionvars(int index) {
  return sessionvars_.Mutable(index);
}
inline ::KeyValueProto* QueryRequest::add_sessionvars() {
  return sessionvars_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KeyValueProto >&
QueryRequest::sessionvars() const {
  return sessionvars_;
}
inline ::google::protobuf::RepeatedPtrField< ::KeyValueProto >*
QueryRequest::mutable_sessionvars() {
  return &sessionvars_;
}

// required bool isJson = 4;
inline bool QueryRequest::has_isjson() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QueryRequest::set_has_isjson() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QueryRequest::clear_has_isjson() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QueryRequest::clear_isjson() {
  isjson_ = false;
  clear_has_isjson();
}
inline bool QueryRequest::isjson() const {
  return isjson_;
}
inline void QueryRequest::set_isjson(bool value) {
  set_has_isjson();
  isjson_ = value;
}

// -------------------------------------------------------------------

// UpdateQueryResponse

// required .ReturnState state = 1;
inline bool UpdateQueryResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateQueryResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateQueryResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateQueryResponse::clear_state() {
  if (state_ != NULL) state_->::ReturnState::Clear();
  clear_has_state();
}
inline const ::ReturnState& UpdateQueryResponse::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::ReturnState* UpdateQueryResponse::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::ReturnState;
  return state_;
}
inline ::ReturnState* UpdateQueryResponse::release_state() {
  clear_has_state();
  ::ReturnState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void UpdateQueryResponse::set_allocated_state(::ReturnState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// optional .KeyValueSetProto sessionVars = 2;
inline bool UpdateQueryResponse::has_sessionvars() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateQueryResponse::set_has_sessionvars() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateQueryResponse::clear_has_sessionvars() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateQueryResponse::clear_sessionvars() {
  if (sessionvars_ != NULL) sessionvars_->::KeyValueSetProto::Clear();
  clear_has_sessionvars();
}
inline const ::KeyValueSetProto& UpdateQueryResponse::sessionvars() const {
  return sessionvars_ != NULL ? *sessionvars_ : *default_instance_->sessionvars_;
}
inline ::KeyValueSetProto* UpdateQueryResponse::mutable_sessionvars() {
  set_has_sessionvars();
  if (sessionvars_ == NULL) sessionvars_ = new ::KeyValueSetProto;
  return sessionvars_;
}
inline ::KeyValueSetProto* UpdateQueryResponse::release_sessionvars() {
  clear_has_sessionvars();
  ::KeyValueSetProto* temp = sessionvars_;
  sessionvars_ = NULL;
  return temp;
}
inline void UpdateQueryResponse::set_allocated_sessionvars(::KeyValueSetProto* sessionvars) {
  delete sessionvars_;
  sessionvars_ = sessionvars;
  if (sessionvars) {
    set_has_sessionvars();
  } else {
    clear_has_sessionvars();
  }
}

// -------------------------------------------------------------------

// GetQueryResultRequest

// optional .SessionIdProto sessionId = 1;
inline bool GetQueryResultRequest::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetQueryResultRequest::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetQueryResultRequest::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetQueryResultRequest::clear_sessionid() {
  if (sessionid_ != NULL) sessionid_->::SessionIdProto::Clear();
  clear_has_sessionid();
}
inline const ::SessionIdProto& GetQueryResultRequest::sessionid() const {
  return sessionid_ != NULL ? *sessionid_ : *default_instance_->sessionid_;
}
inline ::SessionIdProto* GetQueryResultRequest::mutable_sessionid() {
  set_has_sessionid();
  if (sessionid_ == NULL) sessionid_ = new ::SessionIdProto;
  return sessionid_;
}
inline ::SessionIdProto* GetQueryResultRequest::release_sessionid() {
  clear_has_sessionid();
  ::SessionIdProto* temp = sessionid_;
  sessionid_ = NULL;
  return temp;
}
inline void GetQueryResultRequest::set_allocated_sessionid(::SessionIdProto* sessionid) {
  delete sessionid_;
  sessionid_ = sessionid;
  if (sessionid) {
    set_has_sessionid();
  } else {
    clear_has_sessionid();
  }
}

// required .QueryIdProto queryId = 2;
inline bool GetQueryResultRequest::has_queryid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetQueryResultRequest::set_has_queryid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetQueryResultRequest::clear_has_queryid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetQueryResultRequest::clear_queryid() {
  if (queryid_ != NULL) queryid_->::QueryIdProto::Clear();
  clear_has_queryid();
}
inline const ::QueryIdProto& GetQueryResultRequest::queryid() const {
  return queryid_ != NULL ? *queryid_ : *default_instance_->queryid_;
}
inline ::QueryIdProto* GetQueryResultRequest::mutable_queryid() {
  set_has_queryid();
  if (queryid_ == NULL) queryid_ = new ::QueryIdProto;
  return queryid_;
}
inline ::QueryIdProto* GetQueryResultRequest::release_queryid() {
  clear_has_queryid();
  ::QueryIdProto* temp = queryid_;
  queryid_ = NULL;
  return temp;
}
inline void GetQueryResultRequest::set_allocated_queryid(::QueryIdProto* queryid) {
  delete queryid_;
  queryid_ = queryid;
  if (queryid) {
    set_has_queryid();
  } else {
    clear_has_queryid();
  }
}

// -------------------------------------------------------------------

// GetQueryResultResponse

// required .ReturnState state = 1;
inline bool GetQueryResultResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetQueryResultResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetQueryResultResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetQueryResultResponse::clear_state() {
  if (state_ != NULL) state_->::ReturnState::Clear();
  clear_has_state();
}
inline const ::ReturnState& GetQueryResultResponse::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::ReturnState* GetQueryResultResponse::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::ReturnState;
  return state_;
}
inline ::ReturnState* GetQueryResultResponse::release_state() {
  clear_has_state();
  ::ReturnState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void GetQueryResultResponse::set_allocated_state(::ReturnState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// optional .TableDescProto tableDesc = 2;
inline bool GetQueryResultResponse::has_tabledesc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetQueryResultResponse::set_has_tabledesc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetQueryResultResponse::clear_has_tabledesc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetQueryResultResponse::clear_tabledesc() {
  if (tabledesc_ != NULL) tabledesc_->::TableDescProto::Clear();
  clear_has_tabledesc();
}
inline const ::TableDescProto& GetQueryResultResponse::tabledesc() const {
  return tabledesc_ != NULL ? *tabledesc_ : *default_instance_->tabledesc_;
}
inline ::TableDescProto* GetQueryResultResponse::mutable_tabledesc() {
  set_has_tabledesc();
  if (tabledesc_ == NULL) tabledesc_ = new ::TableDescProto;
  return tabledesc_;
}
inline ::TableDescProto* GetQueryResultResponse::release_tabledesc() {
  clear_has_tabledesc();
  ::TableDescProto* temp = tabledesc_;
  tabledesc_ = NULL;
  return temp;
}
inline void GetQueryResultResponse::set_allocated_tabledesc(::TableDescProto* tabledesc) {
  delete tabledesc_;
  tabledesc_ = tabledesc;
  if (tabledesc) {
    set_has_tabledesc();
  } else {
    clear_has_tabledesc();
  }
}

// optional string tajoUserName = 3;
inline bool GetQueryResultResponse::has_tajousername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetQueryResultResponse::set_has_tajousername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetQueryResultResponse::clear_has_tajousername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetQueryResultResponse::clear_tajousername() {
  if (tajousername_ != &::google::protobuf::internal::kEmptyString) {
    tajousername_->clear();
  }
  clear_has_tajousername();
}
inline const ::std::string& GetQueryResultResponse::tajousername() const {
  return *tajousername_;
}
inline void GetQueryResultResponse::set_tajousername(const ::std::string& value) {
  set_has_tajousername();
  if (tajousername_ == &::google::protobuf::internal::kEmptyString) {
    tajousername_ = new ::std::string;
  }
  tajousername_->assign(value);
}
inline void GetQueryResultResponse::set_tajousername(const char* value) {
  set_has_tajousername();
  if (tajousername_ == &::google::protobuf::internal::kEmptyString) {
    tajousername_ = new ::std::string;
  }
  tajousername_->assign(value);
}
inline void GetQueryResultResponse::set_tajousername(const char* value, size_t size) {
  set_has_tajousername();
  if (tajousername_ == &::google::protobuf::internal::kEmptyString) {
    tajousername_ = new ::std::string;
  }
  tajousername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetQueryResultResponse::mutable_tajousername() {
  set_has_tajousername();
  if (tajousername_ == &::google::protobuf::internal::kEmptyString) {
    tajousername_ = new ::std::string;
  }
  return tajousername_;
}
inline ::std::string* GetQueryResultResponse::release_tajousername() {
  clear_has_tajousername();
  if (tajousername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tajousername_;
    tajousername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetQueryResultResponse::set_allocated_tajousername(::std::string* tajousername) {
  if (tajousername_ != &::google::protobuf::internal::kEmptyString) {
    delete tajousername_;
  }
  if (tajousername) {
    set_has_tajousername();
    tajousername_ = tajousername;
  } else {
    clear_has_tajousername();
    tajousername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// QueryIdRequest

// optional .SessionIdProto sessionId = 1;
inline bool QueryIdRequest::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryIdRequest::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryIdRequest::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryIdRequest::clear_sessionid() {
  if (sessionid_ != NULL) sessionid_->::SessionIdProto::Clear();
  clear_has_sessionid();
}
inline const ::SessionIdProto& QueryIdRequest::sessionid() const {
  return sessionid_ != NULL ? *sessionid_ : *default_instance_->sessionid_;
}
inline ::SessionIdProto* QueryIdRequest::mutable_sessionid() {
  set_has_sessionid();
  if (sessionid_ == NULL) sessionid_ = new ::SessionIdProto;
  return sessionid_;
}
inline ::SessionIdProto* QueryIdRequest::release_sessionid() {
  clear_has_sessionid();
  ::SessionIdProto* temp = sessionid_;
  sessionid_ = NULL;
  return temp;
}
inline void QueryIdRequest::set_allocated_sessionid(::SessionIdProto* sessionid) {
  delete sessionid_;
  sessionid_ = sessionid;
  if (sessionid) {
    set_has_sessionid();
  } else {
    clear_has_sessionid();
  }
}

// required .QueryIdProto queryId = 2;
inline bool QueryIdRequest::has_queryid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryIdRequest::set_has_queryid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryIdRequest::clear_has_queryid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryIdRequest::clear_queryid() {
  if (queryid_ != NULL) queryid_->::QueryIdProto::Clear();
  clear_has_queryid();
}
inline const ::QueryIdProto& QueryIdRequest::queryid() const {
  return queryid_ != NULL ? *queryid_ : *default_instance_->queryid_;
}
inline ::QueryIdProto* QueryIdRequest::mutable_queryid() {
  set_has_queryid();
  if (queryid_ == NULL) queryid_ = new ::QueryIdProto;
  return queryid_;
}
inline ::QueryIdProto* QueryIdRequest::release_queryid() {
  clear_has_queryid();
  ::QueryIdProto* temp = queryid_;
  queryid_ = NULL;
  return temp;
}
inline void QueryIdRequest::set_allocated_queryid(::QueryIdProto* queryid) {
  delete queryid_;
  queryid_ = queryid;
  if (queryid) {
    set_has_queryid();
  } else {
    clear_has_queryid();
  }
}

// -------------------------------------------------------------------

// GetQueryListRequest

// optional .SessionIdProto sessionId = 1;
inline bool GetQueryListRequest::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetQueryListRequest::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetQueryListRequest::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetQueryListRequest::clear_sessionid() {
  if (sessionid_ != NULL) sessionid_->::SessionIdProto::Clear();
  clear_has_sessionid();
}
inline const ::SessionIdProto& GetQueryListRequest::sessionid() const {
  return sessionid_ != NULL ? *sessionid_ : *default_instance_->sessionid_;
}
inline ::SessionIdProto* GetQueryListRequest::mutable_sessionid() {
  set_has_sessionid();
  if (sessionid_ == NULL) sessionid_ = new ::SessionIdProto;
  return sessionid_;
}
inline ::SessionIdProto* GetQueryListRequest::release_sessionid() {
  clear_has_sessionid();
  ::SessionIdProto* temp = sessionid_;
  sessionid_ = NULL;
  return temp;
}
inline void GetQueryListRequest::set_allocated_sessionid(::SessionIdProto* sessionid) {
  delete sessionid_;
  sessionid_ = sessionid;
  if (sessionid) {
    set_has_sessionid();
  } else {
    clear_has_sessionid();
  }
}

// -------------------------------------------------------------------

// BriefQueryInfo

// required .QueryIdProto queryId = 1;
inline bool BriefQueryInfo::has_queryid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BriefQueryInfo::set_has_queryid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BriefQueryInfo::clear_has_queryid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BriefQueryInfo::clear_queryid() {
  if (queryid_ != NULL) queryid_->::QueryIdProto::Clear();
  clear_has_queryid();
}
inline const ::QueryIdProto& BriefQueryInfo::queryid() const {
  return queryid_ != NULL ? *queryid_ : *default_instance_->queryid_;
}
inline ::QueryIdProto* BriefQueryInfo::mutable_queryid() {
  set_has_queryid();
  if (queryid_ == NULL) queryid_ = new ::QueryIdProto;
  return queryid_;
}
inline ::QueryIdProto* BriefQueryInfo::release_queryid() {
  clear_has_queryid();
  ::QueryIdProto* temp = queryid_;
  queryid_ = NULL;
  return temp;
}
inline void BriefQueryInfo::set_allocated_queryid(::QueryIdProto* queryid) {
  delete queryid_;
  queryid_ = queryid;
  if (queryid) {
    set_has_queryid();
  } else {
    clear_has_queryid();
  }
}

// required .QueryState state = 2;
inline bool BriefQueryInfo::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BriefQueryInfo::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BriefQueryInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BriefQueryInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::QueryState BriefQueryInfo::state() const {
  return static_cast< ::QueryState >(state_);
}
inline void BriefQueryInfo::set_state(::QueryState value) {
  assert(::QueryState_IsValid(value));
  set_has_state();
  state_ = value;
}

// required int64 startTime = 3;
inline bool BriefQueryInfo::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BriefQueryInfo::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BriefQueryInfo::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BriefQueryInfo::clear_starttime() {
  starttime_ = GOOGLE_LONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::int64 BriefQueryInfo::starttime() const {
  return starttime_;
}
inline void BriefQueryInfo::set_starttime(::google::protobuf::int64 value) {
  set_has_starttime();
  starttime_ = value;
}

// required int64 finishTime = 4;
inline bool BriefQueryInfo::has_finishtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BriefQueryInfo::set_has_finishtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BriefQueryInfo::clear_has_finishtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BriefQueryInfo::clear_finishtime() {
  finishtime_ = GOOGLE_LONGLONG(0);
  clear_has_finishtime();
}
inline ::google::protobuf::int64 BriefQueryInfo::finishtime() const {
  return finishtime_;
}
inline void BriefQueryInfo::set_finishtime(::google::protobuf::int64 value) {
  set_has_finishtime();
  finishtime_ = value;
}

// required string query = 5;
inline bool BriefQueryInfo::has_query() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BriefQueryInfo::set_has_query() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BriefQueryInfo::clear_has_query() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BriefQueryInfo::clear_query() {
  if (query_ != &::google::protobuf::internal::kEmptyString) {
    query_->clear();
  }
  clear_has_query();
}
inline const ::std::string& BriefQueryInfo::query() const {
  return *query_;
}
inline void BriefQueryInfo::set_query(const ::std::string& value) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(value);
}
inline void BriefQueryInfo::set_query(const char* value) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(value);
}
inline void BriefQueryInfo::set_query(const char* value, size_t size) {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  query_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BriefQueryInfo::mutable_query() {
  set_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    query_ = new ::std::string;
  }
  return query_;
}
inline ::std::string* BriefQueryInfo::release_query() {
  clear_has_query();
  if (query_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = query_;
    query_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BriefQueryInfo::set_allocated_query(::std::string* query) {
  if (query_ != &::google::protobuf::internal::kEmptyString) {
    delete query_;
  }
  if (query) {
    set_has_query();
    query_ = query;
  } else {
    clear_has_query();
    query_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string queryMasterHost = 6;
inline bool BriefQueryInfo::has_querymasterhost() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BriefQueryInfo::set_has_querymasterhost() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BriefQueryInfo::clear_has_querymasterhost() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BriefQueryInfo::clear_querymasterhost() {
  if (querymasterhost_ != &::google::protobuf::internal::kEmptyString) {
    querymasterhost_->clear();
  }
  clear_has_querymasterhost();
}
inline const ::std::string& BriefQueryInfo::querymasterhost() const {
  return *querymasterhost_;
}
inline void BriefQueryInfo::set_querymasterhost(const ::std::string& value) {
  set_has_querymasterhost();
  if (querymasterhost_ == &::google::protobuf::internal::kEmptyString) {
    querymasterhost_ = new ::std::string;
  }
  querymasterhost_->assign(value);
}
inline void BriefQueryInfo::set_querymasterhost(const char* value) {
  set_has_querymasterhost();
  if (querymasterhost_ == &::google::protobuf::internal::kEmptyString) {
    querymasterhost_ = new ::std::string;
  }
  querymasterhost_->assign(value);
}
inline void BriefQueryInfo::set_querymasterhost(const char* value, size_t size) {
  set_has_querymasterhost();
  if (querymasterhost_ == &::google::protobuf::internal::kEmptyString) {
    querymasterhost_ = new ::std::string;
  }
  querymasterhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BriefQueryInfo::mutable_querymasterhost() {
  set_has_querymasterhost();
  if (querymasterhost_ == &::google::protobuf::internal::kEmptyString) {
    querymasterhost_ = new ::std::string;
  }
  return querymasterhost_;
}
inline ::std::string* BriefQueryInfo::release_querymasterhost() {
  clear_has_querymasterhost();
  if (querymasterhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = querymasterhost_;
    querymasterhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BriefQueryInfo::set_allocated_querymasterhost(::std::string* querymasterhost) {
  if (querymasterhost_ != &::google::protobuf::internal::kEmptyString) {
    delete querymasterhost_;
  }
  if (querymasterhost) {
    set_has_querymasterhost();
    querymasterhost_ = querymasterhost;
  } else {
    clear_has_querymasterhost();
    querymasterhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 queryMasterPort = 7;
inline bool BriefQueryInfo::has_querymasterport() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BriefQueryInfo::set_has_querymasterport() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BriefQueryInfo::clear_has_querymasterport() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BriefQueryInfo::clear_querymasterport() {
  querymasterport_ = 0;
  clear_has_querymasterport();
}
inline ::google::protobuf::int32 BriefQueryInfo::querymasterport() const {
  return querymasterport_;
}
inline void BriefQueryInfo::set_querymasterport(::google::protobuf::int32 value) {
  set_has_querymasterport();
  querymasterport_ = value;
}

// required float progress = 8;
inline bool BriefQueryInfo::has_progress() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BriefQueryInfo::set_has_progress() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BriefQueryInfo::clear_has_progress() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BriefQueryInfo::clear_progress() {
  progress_ = 0;
  clear_has_progress();
}
inline float BriefQueryInfo::progress() const {
  return progress_;
}
inline void BriefQueryInfo::set_progress(float value) {
  set_has_progress();
  progress_ = value;
}

// -------------------------------------------------------------------

// GetQueryListResponse

// required .ReturnState state = 1;
inline bool GetQueryListResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetQueryListResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetQueryListResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetQueryListResponse::clear_state() {
  if (state_ != NULL) state_->::ReturnState::Clear();
  clear_has_state();
}
inline const ::ReturnState& GetQueryListResponse::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::ReturnState* GetQueryListResponse::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::ReturnState;
  return state_;
}
inline ::ReturnState* GetQueryListResponse::release_state() {
  clear_has_state();
  ::ReturnState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void GetQueryListResponse::set_allocated_state(::ReturnState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// repeated .tajo.client.BriefQueryInfo queryList = 2;
inline int GetQueryListResponse::querylist_size() const {
  return querylist_.size();
}
inline void GetQueryListResponse::clear_querylist() {
  querylist_.Clear();
}
inline const ::tajo::client::BriefQueryInfo& GetQueryListResponse::querylist(int index) const {
  return querylist_.Get(index);
}
inline ::tajo::client::BriefQueryInfo* GetQueryListResponse::mutable_querylist(int index) {
  return querylist_.Mutable(index);
}
inline ::tajo::client::BriefQueryInfo* GetQueryListResponse::add_querylist() {
  return querylist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tajo::client::BriefQueryInfo >&
GetQueryListResponse::querylist() const {
  return querylist_;
}
inline ::google::protobuf::RepeatedPtrField< ::tajo::client::BriefQueryInfo >*
GetQueryListResponse::mutable_querylist() {
  return &querylist_;
}

// -------------------------------------------------------------------

// GetQueryStatusRequest

// optional .SessionIdProto sessionId = 1;
inline bool GetQueryStatusRequest::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetQueryStatusRequest::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetQueryStatusRequest::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetQueryStatusRequest::clear_sessionid() {
  if (sessionid_ != NULL) sessionid_->::SessionIdProto::Clear();
  clear_has_sessionid();
}
inline const ::SessionIdProto& GetQueryStatusRequest::sessionid() const {
  return sessionid_ != NULL ? *sessionid_ : *default_instance_->sessionid_;
}
inline ::SessionIdProto* GetQueryStatusRequest::mutable_sessionid() {
  set_has_sessionid();
  if (sessionid_ == NULL) sessionid_ = new ::SessionIdProto;
  return sessionid_;
}
inline ::SessionIdProto* GetQueryStatusRequest::release_sessionid() {
  clear_has_sessionid();
  ::SessionIdProto* temp = sessionid_;
  sessionid_ = NULL;
  return temp;
}
inline void GetQueryStatusRequest::set_allocated_sessionid(::SessionIdProto* sessionid) {
  delete sessionid_;
  sessionid_ = sessionid;
  if (sessionid) {
    set_has_sessionid();
  } else {
    clear_has_sessionid();
  }
}

// required .QueryIdProto queryId = 2;
inline bool GetQueryStatusRequest::has_queryid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetQueryStatusRequest::set_has_queryid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetQueryStatusRequest::clear_has_queryid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetQueryStatusRequest::clear_queryid() {
  if (queryid_ != NULL) queryid_->::QueryIdProto::Clear();
  clear_has_queryid();
}
inline const ::QueryIdProto& GetQueryStatusRequest::queryid() const {
  return queryid_ != NULL ? *queryid_ : *default_instance_->queryid_;
}
inline ::QueryIdProto* GetQueryStatusRequest::mutable_queryid() {
  set_has_queryid();
  if (queryid_ == NULL) queryid_ = new ::QueryIdProto;
  return queryid_;
}
inline ::QueryIdProto* GetQueryStatusRequest::release_queryid() {
  clear_has_queryid();
  ::QueryIdProto* temp = queryid_;
  queryid_ = NULL;
  return temp;
}
inline void GetQueryStatusRequest::set_allocated_queryid(::QueryIdProto* queryid) {
  delete queryid_;
  queryid_ = queryid;
  if (queryid) {
    set_has_queryid();
  } else {
    clear_has_queryid();
  }
}

// -------------------------------------------------------------------

// SerializedResultSet

// required .SchemaProto schema = 1;
inline bool SerializedResultSet::has_schema() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SerializedResultSet::set_has_schema() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SerializedResultSet::clear_has_schema() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SerializedResultSet::clear_schema() {
  if (schema_ != NULL) schema_->::SchemaProto::Clear();
  clear_has_schema();
}
inline const ::SchemaProto& SerializedResultSet::schema() const {
  return schema_ != NULL ? *schema_ : *default_instance_->schema_;
}
inline ::SchemaProto* SerializedResultSet::mutable_schema() {
  set_has_schema();
  if (schema_ == NULL) schema_ = new ::SchemaProto;
  return schema_;
}
inline ::SchemaProto* SerializedResultSet::release_schema() {
  clear_has_schema();
  ::SchemaProto* temp = schema_;
  schema_ = NULL;
  return temp;
}
inline void SerializedResultSet::set_allocated_schema(::SchemaProto* schema) {
  delete schema_;
  schema_ = schema;
  if (schema) {
    set_has_schema();
  } else {
    clear_has_schema();
  }
}

// required int32 rows = 2;
inline bool SerializedResultSet::has_rows() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SerializedResultSet::set_has_rows() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SerializedResultSet::clear_has_rows() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SerializedResultSet::clear_rows() {
  rows_ = 0;
  clear_has_rows();
}
inline ::google::protobuf::int32 SerializedResultSet::rows() const {
  return rows_;
}
inline void SerializedResultSet::set_rows(::google::protobuf::int32 value) {
  set_has_rows();
  rows_ = value;
}

// optional int32 decompressedLength = 3;
inline bool SerializedResultSet::has_decompressedlength() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SerializedResultSet::set_has_decompressedlength() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SerializedResultSet::clear_has_decompressedlength() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SerializedResultSet::clear_decompressedlength() {
  decompressedlength_ = 0;
  clear_has_decompressedlength();
}
inline ::google::protobuf::int32 SerializedResultSet::decompressedlength() const {
  return decompressedlength_;
}
inline void SerializedResultSet::set_decompressedlength(::google::protobuf::int32 value) {
  set_has_decompressedlength();
  decompressedlength_ = value;
}

// optional .CodecType decompressCodec = 4;
inline bool SerializedResultSet::has_decompresscodec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SerializedResultSet::set_has_decompresscodec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SerializedResultSet::clear_has_decompresscodec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SerializedResultSet::clear_decompresscodec() {
  decompresscodec_ = 0;
  clear_has_decompresscodec();
}
inline ::CodecType SerializedResultSet::decompresscodec() const {
  return static_cast< ::CodecType >(decompresscodec_);
}
inline void SerializedResultSet::set_decompresscodec(::CodecType value) {
  assert(::CodecType_IsValid(value));
  set_has_decompresscodec();
  decompresscodec_ = value;
}

// optional bytes serializedTuples = 5;
inline bool SerializedResultSet::has_serializedtuples() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SerializedResultSet::set_has_serializedtuples() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SerializedResultSet::clear_has_serializedtuples() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SerializedResultSet::clear_serializedtuples() {
  if (serializedtuples_ != &::google::protobuf::internal::kEmptyString) {
    serializedtuples_->clear();
  }
  clear_has_serializedtuples();
}
inline const ::std::string& SerializedResultSet::serializedtuples() const {
  return *serializedtuples_;
}
inline void SerializedResultSet::set_serializedtuples(const ::std::string& value) {
  set_has_serializedtuples();
  if (serializedtuples_ == &::google::protobuf::internal::kEmptyString) {
    serializedtuples_ = new ::std::string;
  }
  serializedtuples_->assign(value);
}
inline void SerializedResultSet::set_serializedtuples(const char* value) {
  set_has_serializedtuples();
  if (serializedtuples_ == &::google::protobuf::internal::kEmptyString) {
    serializedtuples_ = new ::std::string;
  }
  serializedtuples_->assign(value);
}
inline void SerializedResultSet::set_serializedtuples(const void* value, size_t size) {
  set_has_serializedtuples();
  if (serializedtuples_ == &::google::protobuf::internal::kEmptyString) {
    serializedtuples_ = new ::std::string;
  }
  serializedtuples_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SerializedResultSet::mutable_serializedtuples() {
  set_has_serializedtuples();
  if (serializedtuples_ == &::google::protobuf::internal::kEmptyString) {
    serializedtuples_ = new ::std::string;
  }
  return serializedtuples_;
}
inline ::std::string* SerializedResultSet::release_serializedtuples() {
  clear_has_serializedtuples();
  if (serializedtuples_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serializedtuples_;
    serializedtuples_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SerializedResultSet::set_allocated_serializedtuples(::std::string* serializedtuples) {
  if (serializedtuples_ != &::google::protobuf::internal::kEmptyString) {
    delete serializedtuples_;
  }
  if (serializedtuples) {
    set_has_serializedtuples();
    serializedtuples_ = serializedtuples;
  } else {
    clear_has_serializedtuples();
    serializedtuples_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SubmitQueryResponse

// required .ReturnState state = 1;
inline bool SubmitQueryResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubmitQueryResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubmitQueryResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubmitQueryResponse::clear_state() {
  if (state_ != NULL) state_->::ReturnState::Clear();
  clear_has_state();
}
inline const ::ReturnState& SubmitQueryResponse::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::ReturnState* SubmitQueryResponse::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::ReturnState;
  return state_;
}
inline ::ReturnState* SubmitQueryResponse::release_state() {
  clear_has_state();
  ::ReturnState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void SubmitQueryResponse::set_allocated_state(::ReturnState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// optional .tajo.client.SubmitQueryResponse.ResultType result_type = 2;
inline bool SubmitQueryResponse::has_result_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubmitQueryResponse::set_has_result_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubmitQueryResponse::clear_has_result_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubmitQueryResponse::clear_result_type() {
  result_type_ = 0;
  clear_has_result_type();
}
inline ::tajo::client::SubmitQueryResponse_ResultType SubmitQueryResponse::result_type() const {
  return static_cast< ::tajo::client::SubmitQueryResponse_ResultType >(result_type_);
}
inline void SubmitQueryResponse::set_result_type(::tajo::client::SubmitQueryResponse_ResultType value) {
  assert(::tajo::client::SubmitQueryResponse_ResultType_IsValid(value));
  set_has_result_type();
  result_type_ = value;
}

// optional .QueryIdProto queryId = 3;
inline bool SubmitQueryResponse::has_queryid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubmitQueryResponse::set_has_queryid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubmitQueryResponse::clear_has_queryid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubmitQueryResponse::clear_queryid() {
  if (queryid_ != NULL) queryid_->::QueryIdProto::Clear();
  clear_has_queryid();
}
inline const ::QueryIdProto& SubmitQueryResponse::queryid() const {
  return queryid_ != NULL ? *queryid_ : *default_instance_->queryid_;
}
inline ::QueryIdProto* SubmitQueryResponse::mutable_queryid() {
  set_has_queryid();
  if (queryid_ == NULL) queryid_ = new ::QueryIdProto;
  return queryid_;
}
inline ::QueryIdProto* SubmitQueryResponse::release_queryid() {
  clear_has_queryid();
  ::QueryIdProto* temp = queryid_;
  queryid_ = NULL;
  return temp;
}
inline void SubmitQueryResponse::set_allocated_queryid(::QueryIdProto* queryid) {
  delete queryid_;
  queryid_ = queryid;
  if (queryid) {
    set_has_queryid();
  } else {
    clear_has_queryid();
  }
}

// optional string userName = 4;
inline bool SubmitQueryResponse::has_username() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubmitQueryResponse::set_has_username() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubmitQueryResponse::clear_has_username() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubmitQueryResponse::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& SubmitQueryResponse::username() const {
  return *username_;
}
inline void SubmitQueryResponse::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void SubmitQueryResponse::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void SubmitQueryResponse::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubmitQueryResponse::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* SubmitQueryResponse::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SubmitQueryResponse::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string queryMasterHost = 6;
inline bool SubmitQueryResponse::has_querymasterhost() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubmitQueryResponse::set_has_querymasterhost() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubmitQueryResponse::clear_has_querymasterhost() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubmitQueryResponse::clear_querymasterhost() {
  if (querymasterhost_ != &::google::protobuf::internal::kEmptyString) {
    querymasterhost_->clear();
  }
  clear_has_querymasterhost();
}
inline const ::std::string& SubmitQueryResponse::querymasterhost() const {
  return *querymasterhost_;
}
inline void SubmitQueryResponse::set_querymasterhost(const ::std::string& value) {
  set_has_querymasterhost();
  if (querymasterhost_ == &::google::protobuf::internal::kEmptyString) {
    querymasterhost_ = new ::std::string;
  }
  querymasterhost_->assign(value);
}
inline void SubmitQueryResponse::set_querymasterhost(const char* value) {
  set_has_querymasterhost();
  if (querymasterhost_ == &::google::protobuf::internal::kEmptyString) {
    querymasterhost_ = new ::std::string;
  }
  querymasterhost_->assign(value);
}
inline void SubmitQueryResponse::set_querymasterhost(const char* value, size_t size) {
  set_has_querymasterhost();
  if (querymasterhost_ == &::google::protobuf::internal::kEmptyString) {
    querymasterhost_ = new ::std::string;
  }
  querymasterhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubmitQueryResponse::mutable_querymasterhost() {
  set_has_querymasterhost();
  if (querymasterhost_ == &::google::protobuf::internal::kEmptyString) {
    querymasterhost_ = new ::std::string;
  }
  return querymasterhost_;
}
inline ::std::string* SubmitQueryResponse::release_querymasterhost() {
  clear_has_querymasterhost();
  if (querymasterhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = querymasterhost_;
    querymasterhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SubmitQueryResponse::set_allocated_querymasterhost(::std::string* querymasterhost) {
  if (querymasterhost_ != &::google::protobuf::internal::kEmptyString) {
    delete querymasterhost_;
  }
  if (querymasterhost) {
    set_has_querymasterhost();
    querymasterhost_ = querymasterhost;
  } else {
    clear_has_querymasterhost();
    querymasterhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 queryMasterPort = 7;
inline bool SubmitQueryResponse::has_querymasterport() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SubmitQueryResponse::set_has_querymasterport() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SubmitQueryResponse::clear_has_querymasterport() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SubmitQueryResponse::clear_querymasterport() {
  querymasterport_ = 0;
  clear_has_querymasterport();
}
inline ::google::protobuf::int32 SubmitQueryResponse::querymasterport() const {
  return querymasterport_;
}
inline void SubmitQueryResponse::set_querymasterport(::google::protobuf::int32 value) {
  set_has_querymasterport();
  querymasterport_ = value;
}

// optional .tajo.client.SerializedResultSet resultSet = 8;
inline bool SubmitQueryResponse::has_resultset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SubmitQueryResponse::set_has_resultset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SubmitQueryResponse::clear_has_resultset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SubmitQueryResponse::clear_resultset() {
  if (resultset_ != NULL) resultset_->::tajo::client::SerializedResultSet::Clear();
  clear_has_resultset();
}
inline const ::tajo::client::SerializedResultSet& SubmitQueryResponse::resultset() const {
  return resultset_ != NULL ? *resultset_ : *default_instance_->resultset_;
}
inline ::tajo::client::SerializedResultSet* SubmitQueryResponse::mutable_resultset() {
  set_has_resultset();
  if (resultset_ == NULL) resultset_ = new ::tajo::client::SerializedResultSet;
  return resultset_;
}
inline ::tajo::client::SerializedResultSet* SubmitQueryResponse::release_resultset() {
  clear_has_resultset();
  ::tajo::client::SerializedResultSet* temp = resultset_;
  resultset_ = NULL;
  return temp;
}
inline void SubmitQueryResponse::set_allocated_resultset(::tajo::client::SerializedResultSet* resultset) {
  delete resultset_;
  resultset_ = resultset;
  if (resultset) {
    set_has_resultset();
  } else {
    clear_has_resultset();
  }
}

// optional .TableDescProto tableDesc = 9;
inline bool SubmitQueryResponse::has_tabledesc() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SubmitQueryResponse::set_has_tabledesc() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SubmitQueryResponse::clear_has_tabledesc() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SubmitQueryResponse::clear_tabledesc() {
  if (tabledesc_ != NULL) tabledesc_->::TableDescProto::Clear();
  clear_has_tabledesc();
}
inline const ::TableDescProto& SubmitQueryResponse::tabledesc() const {
  return tabledesc_ != NULL ? *tabledesc_ : *default_instance_->tabledesc_;
}
inline ::TableDescProto* SubmitQueryResponse::mutable_tabledesc() {
  set_has_tabledesc();
  if (tabledesc_ == NULL) tabledesc_ = new ::TableDescProto;
  return tabledesc_;
}
inline ::TableDescProto* SubmitQueryResponse::release_tabledesc() {
  clear_has_tabledesc();
  ::TableDescProto* temp = tabledesc_;
  tabledesc_ = NULL;
  return temp;
}
inline void SubmitQueryResponse::set_allocated_tabledesc(::TableDescProto* tabledesc) {
  delete tabledesc_;
  tabledesc_ = tabledesc;
  if (tabledesc) {
    set_has_tabledesc();
  } else {
    clear_has_tabledesc();
  }
}

// optional int32 maxRowNum = 10;
inline bool SubmitQueryResponse::has_maxrownum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SubmitQueryResponse::set_has_maxrownum() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SubmitQueryResponse::clear_has_maxrownum() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SubmitQueryResponse::clear_maxrownum() {
  maxrownum_ = 0;
  clear_has_maxrownum();
}
inline ::google::protobuf::int32 SubmitQueryResponse::maxrownum() const {
  return maxrownum_;
}
inline void SubmitQueryResponse::set_maxrownum(::google::protobuf::int32 value) {
  set_has_maxrownum();
  maxrownum_ = value;
}

// optional .KeyValueSetProto sessionVars = 11;
inline bool SubmitQueryResponse::has_sessionvars() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SubmitQueryResponse::set_has_sessionvars() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SubmitQueryResponse::clear_has_sessionvars() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SubmitQueryResponse::clear_sessionvars() {
  if (sessionvars_ != NULL) sessionvars_->::KeyValueSetProto::Clear();
  clear_has_sessionvars();
}
inline const ::KeyValueSetProto& SubmitQueryResponse::sessionvars() const {
  return sessionvars_ != NULL ? *sessionvars_ : *default_instance_->sessionvars_;
}
inline ::KeyValueSetProto* SubmitQueryResponse::mutable_sessionvars() {
  set_has_sessionvars();
  if (sessionvars_ == NULL) sessionvars_ = new ::KeyValueSetProto;
  return sessionvars_;
}
inline ::KeyValueSetProto* SubmitQueryResponse::release_sessionvars() {
  clear_has_sessionvars();
  ::KeyValueSetProto* temp = sessionvars_;
  sessionvars_ = NULL;
  return temp;
}
inline void SubmitQueryResponse::set_allocated_sessionvars(::KeyValueSetProto* sessionvars) {
  delete sessionvars_;
  sessionvars_ = sessionvars;
  if (sessionvars) {
    set_has_sessionvars();
  } else {
    clear_has_sessionvars();
  }
}

// -------------------------------------------------------------------

// GetQueryStatusResponse

// required .ReturnState state = 1;
inline bool GetQueryStatusResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetQueryStatusResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetQueryStatusResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetQueryStatusResponse::clear_state() {
  if (state_ != NULL) state_->::ReturnState::Clear();
  clear_has_state();
}
inline const ::ReturnState& GetQueryStatusResponse::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::ReturnState* GetQueryStatusResponse::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::ReturnState;
  return state_;
}
inline ::ReturnState* GetQueryStatusResponse::release_state() {
  clear_has_state();
  ::ReturnState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void GetQueryStatusResponse::set_allocated_state(::ReturnState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// optional .QueryIdProto queryId = 2;
inline bool GetQueryStatusResponse::has_queryid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetQueryStatusResponse::set_has_queryid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetQueryStatusResponse::clear_has_queryid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetQueryStatusResponse::clear_queryid() {
  if (queryid_ != NULL) queryid_->::QueryIdProto::Clear();
  clear_has_queryid();
}
inline const ::QueryIdProto& GetQueryStatusResponse::queryid() const {
  return queryid_ != NULL ? *queryid_ : *default_instance_->queryid_;
}
inline ::QueryIdProto* GetQueryStatusResponse::mutable_queryid() {
  set_has_queryid();
  if (queryid_ == NULL) queryid_ = new ::QueryIdProto;
  return queryid_;
}
inline ::QueryIdProto* GetQueryStatusResponse::release_queryid() {
  clear_has_queryid();
  ::QueryIdProto* temp = queryid_;
  queryid_ = NULL;
  return temp;
}
inline void GetQueryStatusResponse::set_allocated_queryid(::QueryIdProto* queryid) {
  delete queryid_;
  queryid_ = queryid;
  if (queryid) {
    set_has_queryid();
  } else {
    clear_has_queryid();
  }
}

// optional .QueryState query_state = 3;
inline bool GetQueryStatusResponse::has_query_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetQueryStatusResponse::set_has_query_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetQueryStatusResponse::clear_has_query_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetQueryStatusResponse::clear_query_state() {
  query_state_ = 0;
  clear_has_query_state();
}
inline ::QueryState GetQueryStatusResponse::query_state() const {
  return static_cast< ::QueryState >(query_state_);
}
inline void GetQueryStatusResponse::set_query_state(::QueryState value) {
  assert(::QueryState_IsValid(value));
  set_has_query_state();
  query_state_ = value;
}

// optional float progress = 4;
inline bool GetQueryStatusResponse::has_progress() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetQueryStatusResponse::set_has_progress() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetQueryStatusResponse::clear_has_progress() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetQueryStatusResponse::clear_progress() {
  progress_ = 0;
  clear_has_progress();
}
inline float GetQueryStatusResponse::progress() const {
  return progress_;
}
inline void GetQueryStatusResponse::set_progress(float value) {
  set_has_progress();
  progress_ = value;
}

// optional int64 submitTime = 5;
inline bool GetQueryStatusResponse::has_submittime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetQueryStatusResponse::set_has_submittime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetQueryStatusResponse::clear_has_submittime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetQueryStatusResponse::clear_submittime() {
  submittime_ = GOOGLE_LONGLONG(0);
  clear_has_submittime();
}
inline ::google::protobuf::int64 GetQueryStatusResponse::submittime() const {
  return submittime_;
}
inline void GetQueryStatusResponse::set_submittime(::google::protobuf::int64 value) {
  set_has_submittime();
  submittime_ = value;
}

// optional int64 finishTime = 7;
inline bool GetQueryStatusResponse::has_finishtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetQueryStatusResponse::set_has_finishtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetQueryStatusResponse::clear_has_finishtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetQueryStatusResponse::clear_finishtime() {
  finishtime_ = GOOGLE_LONGLONG(0);
  clear_has_finishtime();
}
inline ::google::protobuf::int64 GetQueryStatusResponse::finishtime() const {
  return finishtime_;
}
inline void GetQueryStatusResponse::set_finishtime(::google::protobuf::int64 value) {
  set_has_finishtime();
  finishtime_ = value;
}

// optional bool hasResult = 8;
inline bool GetQueryStatusResponse::has_hasresult() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetQueryStatusResponse::set_has_hasresult() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetQueryStatusResponse::clear_has_hasresult() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetQueryStatusResponse::clear_hasresult() {
  hasresult_ = false;
  clear_has_hasresult();
}
inline bool GetQueryStatusResponse::hasresult() const {
  return hasresult_;
}
inline void GetQueryStatusResponse::set_hasresult(bool value) {
  set_has_hasresult();
  hasresult_ = value;
}

// optional string errorMessage = 9;
inline bool GetQueryStatusResponse::has_errormessage() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GetQueryStatusResponse::set_has_errormessage() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GetQueryStatusResponse::clear_has_errormessage() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GetQueryStatusResponse::clear_errormessage() {
  if (errormessage_ != &::google::protobuf::internal::kEmptyString) {
    errormessage_->clear();
  }
  clear_has_errormessage();
}
inline const ::std::string& GetQueryStatusResponse::errormessage() const {
  return *errormessage_;
}
inline void GetQueryStatusResponse::set_errormessage(const ::std::string& value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
}
inline void GetQueryStatusResponse::set_errormessage(const char* value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
}
inline void GetQueryStatusResponse::set_errormessage(const char* value, size_t size) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetQueryStatusResponse::mutable_errormessage() {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  return errormessage_;
}
inline ::std::string* GetQueryStatusResponse::release_errormessage() {
  clear_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errormessage_;
    errormessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetQueryStatusResponse::set_allocated_errormessage(::std::string* errormessage) {
  if (errormessage_ != &::google::protobuf::internal::kEmptyString) {
    delete errormessage_;
  }
  if (errormessage) {
    set_has_errormessage();
    errormessage_ = errormessage;
  } else {
    clear_has_errormessage();
    errormessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string errorTrace = 10;
inline bool GetQueryStatusResponse::has_errortrace() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GetQueryStatusResponse::set_has_errortrace() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GetQueryStatusResponse::clear_has_errortrace() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GetQueryStatusResponse::clear_errortrace() {
  if (errortrace_ != &::google::protobuf::internal::kEmptyString) {
    errortrace_->clear();
  }
  clear_has_errortrace();
}
inline const ::std::string& GetQueryStatusResponse::errortrace() const {
  return *errortrace_;
}
inline void GetQueryStatusResponse::set_errortrace(const ::std::string& value) {
  set_has_errortrace();
  if (errortrace_ == &::google::protobuf::internal::kEmptyString) {
    errortrace_ = new ::std::string;
  }
  errortrace_->assign(value);
}
inline void GetQueryStatusResponse::set_errortrace(const char* value) {
  set_has_errortrace();
  if (errortrace_ == &::google::protobuf::internal::kEmptyString) {
    errortrace_ = new ::std::string;
  }
  errortrace_->assign(value);
}
inline void GetQueryStatusResponse::set_errortrace(const char* value, size_t size) {
  set_has_errortrace();
  if (errortrace_ == &::google::protobuf::internal::kEmptyString) {
    errortrace_ = new ::std::string;
  }
  errortrace_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetQueryStatusResponse::mutable_errortrace() {
  set_has_errortrace();
  if (errortrace_ == &::google::protobuf::internal::kEmptyString) {
    errortrace_ = new ::std::string;
  }
  return errortrace_;
}
inline ::std::string* GetQueryStatusResponse::release_errortrace() {
  clear_has_errortrace();
  if (errortrace_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errortrace_;
    errortrace_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetQueryStatusResponse::set_allocated_errortrace(::std::string* errortrace) {
  if (errortrace_ != &::google::protobuf::internal::kEmptyString) {
    delete errortrace_;
  }
  if (errortrace) {
    set_has_errortrace();
    errortrace_ = errortrace;
  } else {
    clear_has_errortrace();
    errortrace_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string queryMasterHost = 11;
inline bool GetQueryStatusResponse::has_querymasterhost() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GetQueryStatusResponse::set_has_querymasterhost() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GetQueryStatusResponse::clear_has_querymasterhost() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GetQueryStatusResponse::clear_querymasterhost() {
  if (querymasterhost_ != &::google::protobuf::internal::kEmptyString) {
    querymasterhost_->clear();
  }
  clear_has_querymasterhost();
}
inline const ::std::string& GetQueryStatusResponse::querymasterhost() const {
  return *querymasterhost_;
}
inline void GetQueryStatusResponse::set_querymasterhost(const ::std::string& value) {
  set_has_querymasterhost();
  if (querymasterhost_ == &::google::protobuf::internal::kEmptyString) {
    querymasterhost_ = new ::std::string;
  }
  querymasterhost_->assign(value);
}
inline void GetQueryStatusResponse::set_querymasterhost(const char* value) {
  set_has_querymasterhost();
  if (querymasterhost_ == &::google::protobuf::internal::kEmptyString) {
    querymasterhost_ = new ::std::string;
  }
  querymasterhost_->assign(value);
}
inline void GetQueryStatusResponse::set_querymasterhost(const char* value, size_t size) {
  set_has_querymasterhost();
  if (querymasterhost_ == &::google::protobuf::internal::kEmptyString) {
    querymasterhost_ = new ::std::string;
  }
  querymasterhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetQueryStatusResponse::mutable_querymasterhost() {
  set_has_querymasterhost();
  if (querymasterhost_ == &::google::protobuf::internal::kEmptyString) {
    querymasterhost_ = new ::std::string;
  }
  return querymasterhost_;
}
inline ::std::string* GetQueryStatusResponse::release_querymasterhost() {
  clear_has_querymasterhost();
  if (querymasterhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = querymasterhost_;
    querymasterhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetQueryStatusResponse::set_allocated_querymasterhost(::std::string* querymasterhost) {
  if (querymasterhost_ != &::google::protobuf::internal::kEmptyString) {
    delete querymasterhost_;
  }
  if (querymasterhost) {
    set_has_querymasterhost();
    querymasterhost_ = querymasterhost;
  } else {
    clear_has_querymasterhost();
    querymasterhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 queryMasterPort = 12;
inline bool GetQueryStatusResponse::has_querymasterport() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GetQueryStatusResponse::set_has_querymasterport() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GetQueryStatusResponse::clear_has_querymasterport() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GetQueryStatusResponse::clear_querymasterport() {
  querymasterport_ = 0;
  clear_has_querymasterport();
}
inline ::google::protobuf::int32 GetQueryStatusResponse::querymasterport() const {
  return querymasterport_;
}
inline void GetQueryStatusResponse::set_querymasterport(::google::protobuf::int32 value) {
  set_has_querymasterport();
  querymasterport_ = value;
}

// -------------------------------------------------------------------

// GetQueryResultDataRequest

// required .SessionIdProto sessionId = 1;
inline bool GetQueryResultDataRequest::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetQueryResultDataRequest::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetQueryResultDataRequest::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetQueryResultDataRequest::clear_sessionid() {
  if (sessionid_ != NULL) sessionid_->::SessionIdProto::Clear();
  clear_has_sessionid();
}
inline const ::SessionIdProto& GetQueryResultDataRequest::sessionid() const {
  return sessionid_ != NULL ? *sessionid_ : *default_instance_->sessionid_;
}
inline ::SessionIdProto* GetQueryResultDataRequest::mutable_sessionid() {
  set_has_sessionid();
  if (sessionid_ == NULL) sessionid_ = new ::SessionIdProto;
  return sessionid_;
}
inline ::SessionIdProto* GetQueryResultDataRequest::release_sessionid() {
  clear_has_sessionid();
  ::SessionIdProto* temp = sessionid_;
  sessionid_ = NULL;
  return temp;
}
inline void GetQueryResultDataRequest::set_allocated_sessionid(::SessionIdProto* sessionid) {
  delete sessionid_;
  sessionid_ = sessionid;
  if (sessionid) {
    set_has_sessionid();
  } else {
    clear_has_sessionid();
  }
}

// required .QueryIdProto queryId = 2;
inline bool GetQueryResultDataRequest::has_queryid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetQueryResultDataRequest::set_has_queryid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetQueryResultDataRequest::clear_has_queryid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetQueryResultDataRequest::clear_queryid() {
  if (queryid_ != NULL) queryid_->::QueryIdProto::Clear();
  clear_has_queryid();
}
inline const ::QueryIdProto& GetQueryResultDataRequest::queryid() const {
  return queryid_ != NULL ? *queryid_ : *default_instance_->queryid_;
}
inline ::QueryIdProto* GetQueryResultDataRequest::mutable_queryid() {
  set_has_queryid();
  if (queryid_ == NULL) queryid_ = new ::QueryIdProto;
  return queryid_;
}
inline ::QueryIdProto* GetQueryResultDataRequest::release_queryid() {
  clear_has_queryid();
  ::QueryIdProto* temp = queryid_;
  queryid_ = NULL;
  return temp;
}
inline void GetQueryResultDataRequest::set_allocated_queryid(::QueryIdProto* queryid) {
  delete queryid_;
  queryid_ = queryid;
  if (queryid) {
    set_has_queryid();
  } else {
    clear_has_queryid();
  }
}

// required int32 fetchRowNum = 3;
inline bool GetQueryResultDataRequest::has_fetchrownum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetQueryResultDataRequest::set_has_fetchrownum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetQueryResultDataRequest::clear_has_fetchrownum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetQueryResultDataRequest::clear_fetchrownum() {
  fetchrownum_ = 0;
  clear_has_fetchrownum();
}
inline ::google::protobuf::int32 GetQueryResultDataRequest::fetchrownum() const {
  return fetchrownum_;
}
inline void GetQueryResultDataRequest::set_fetchrownum(::google::protobuf::int32 value) {
  set_has_fetchrownum();
  fetchrownum_ = value;
}

// optional .CodecType compressCodec = 4;
inline bool GetQueryResultDataRequest::has_compresscodec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetQueryResultDataRequest::set_has_compresscodec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetQueryResultDataRequest::clear_has_compresscodec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetQueryResultDataRequest::clear_compresscodec() {
  compresscodec_ = 0;
  clear_has_compresscodec();
}
inline ::CodecType GetQueryResultDataRequest::compresscodec() const {
  return static_cast< ::CodecType >(compresscodec_);
}
inline void GetQueryResultDataRequest::set_compresscodec(::CodecType value) {
  assert(::CodecType_IsValid(value));
  set_has_compresscodec();
  compresscodec_ = value;
}

// -------------------------------------------------------------------

// GetQueryResultDataResponse

// required .ReturnState state = 1;
inline bool GetQueryResultDataResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetQueryResultDataResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetQueryResultDataResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetQueryResultDataResponse::clear_state() {
  if (state_ != NULL) state_->::ReturnState::Clear();
  clear_has_state();
}
inline const ::ReturnState& GetQueryResultDataResponse::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::ReturnState* GetQueryResultDataResponse::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::ReturnState;
  return state_;
}
inline ::ReturnState* GetQueryResultDataResponse::release_state() {
  clear_has_state();
  ::ReturnState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void GetQueryResultDataResponse::set_allocated_state(::ReturnState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// optional .tajo.client.SerializedResultSet resultSet = 2;
inline bool GetQueryResultDataResponse::has_resultset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetQueryResultDataResponse::set_has_resultset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetQueryResultDataResponse::clear_has_resultset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetQueryResultDataResponse::clear_resultset() {
  if (resultset_ != NULL) resultset_->::tajo::client::SerializedResultSet::Clear();
  clear_has_resultset();
}
inline const ::tajo::client::SerializedResultSet& GetQueryResultDataResponse::resultset() const {
  return resultset_ != NULL ? *resultset_ : *default_instance_->resultset_;
}
inline ::tajo::client::SerializedResultSet* GetQueryResultDataResponse::mutable_resultset() {
  set_has_resultset();
  if (resultset_ == NULL) resultset_ = new ::tajo::client::SerializedResultSet;
  return resultset_;
}
inline ::tajo::client::SerializedResultSet* GetQueryResultDataResponse::release_resultset() {
  clear_has_resultset();
  ::tajo::client::SerializedResultSet* temp = resultset_;
  resultset_ = NULL;
  return temp;
}
inline void GetQueryResultDataResponse::set_allocated_resultset(::tajo::client::SerializedResultSet* resultset) {
  delete resultset_;
  resultset_ = resultset;
  if (resultset) {
    set_has_resultset();
  } else {
    clear_has_resultset();
  }
}

// -------------------------------------------------------------------

// GetClusterInfoRequest

// optional .SessionIdProto sessionId = 1;
inline bool GetClusterInfoRequest::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetClusterInfoRequest::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetClusterInfoRequest::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetClusterInfoRequest::clear_sessionid() {
  if (sessionid_ != NULL) sessionid_->::SessionIdProto::Clear();
  clear_has_sessionid();
}
inline const ::SessionIdProto& GetClusterInfoRequest::sessionid() const {
  return sessionid_ != NULL ? *sessionid_ : *default_instance_->sessionid_;
}
inline ::SessionIdProto* GetClusterInfoRequest::mutable_sessionid() {
  set_has_sessionid();
  if (sessionid_ == NULL) sessionid_ = new ::SessionIdProto;
  return sessionid_;
}
inline ::SessionIdProto* GetClusterInfoRequest::release_sessionid() {
  clear_has_sessionid();
  ::SessionIdProto* temp = sessionid_;
  sessionid_ = NULL;
  return temp;
}
inline void GetClusterInfoRequest::set_allocated_sessionid(::SessionIdProto* sessionid) {
  delete sessionid_;
  sessionid_ = sessionid;
  if (sessionid) {
    set_has_sessionid();
  } else {
    clear_has_sessionid();
  }
}

// -------------------------------------------------------------------

// WorkerResourceInfo

// required .WorkerConnectionInfoProto connectionInfo = 1;
inline bool WorkerResourceInfo::has_connectioninfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WorkerResourceInfo::set_has_connectioninfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WorkerResourceInfo::clear_has_connectioninfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WorkerResourceInfo::clear_connectioninfo() {
  if (connectioninfo_ != NULL) connectioninfo_->::WorkerConnectionInfoProto::Clear();
  clear_has_connectioninfo();
}
inline const ::WorkerConnectionInfoProto& WorkerResourceInfo::connectioninfo() const {
  return connectioninfo_ != NULL ? *connectioninfo_ : *default_instance_->connectioninfo_;
}
inline ::WorkerConnectionInfoProto* WorkerResourceInfo::mutable_connectioninfo() {
  set_has_connectioninfo();
  if (connectioninfo_ == NULL) connectioninfo_ = new ::WorkerConnectionInfoProto;
  return connectioninfo_;
}
inline ::WorkerConnectionInfoProto* WorkerResourceInfo::release_connectioninfo() {
  clear_has_connectioninfo();
  ::WorkerConnectionInfoProto* temp = connectioninfo_;
  connectioninfo_ = NULL;
  return temp;
}
inline void WorkerResourceInfo::set_allocated_connectioninfo(::WorkerConnectionInfoProto* connectioninfo) {
  delete connectioninfo_;
  connectioninfo_ = connectioninfo;
  if (connectioninfo) {
    set_has_connectioninfo();
  } else {
    clear_has_connectioninfo();
  }
}

// required .NodeResourceProto totalResource = 2;
inline bool WorkerResourceInfo::has_totalresource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WorkerResourceInfo::set_has_totalresource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WorkerResourceInfo::clear_has_totalresource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WorkerResourceInfo::clear_totalresource() {
  if (totalresource_ != NULL) totalresource_->::NodeResourceProto::Clear();
  clear_has_totalresource();
}
inline const ::NodeResourceProto& WorkerResourceInfo::totalresource() const {
  return totalresource_ != NULL ? *totalresource_ : *default_instance_->totalresource_;
}
inline ::NodeResourceProto* WorkerResourceInfo::mutable_totalresource() {
  set_has_totalresource();
  if (totalresource_ == NULL) totalresource_ = new ::NodeResourceProto;
  return totalresource_;
}
inline ::NodeResourceProto* WorkerResourceInfo::release_totalresource() {
  clear_has_totalresource();
  ::NodeResourceProto* temp = totalresource_;
  totalresource_ = NULL;
  return temp;
}
inline void WorkerResourceInfo::set_allocated_totalresource(::NodeResourceProto* totalresource) {
  delete totalresource_;
  totalresource_ = totalresource;
  if (totalresource) {
    set_has_totalresource();
  } else {
    clear_has_totalresource();
  }
}

// required .NodeResourceProto availableResource = 3;
inline bool WorkerResourceInfo::has_availableresource() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WorkerResourceInfo::set_has_availableresource() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WorkerResourceInfo::clear_has_availableresource() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WorkerResourceInfo::clear_availableresource() {
  if (availableresource_ != NULL) availableresource_->::NodeResourceProto::Clear();
  clear_has_availableresource();
}
inline const ::NodeResourceProto& WorkerResourceInfo::availableresource() const {
  return availableresource_ != NULL ? *availableresource_ : *default_instance_->availableresource_;
}
inline ::NodeResourceProto* WorkerResourceInfo::mutable_availableresource() {
  set_has_availableresource();
  if (availableresource_ == NULL) availableresource_ = new ::NodeResourceProto;
  return availableresource_;
}
inline ::NodeResourceProto* WorkerResourceInfo::release_availableresource() {
  clear_has_availableresource();
  ::NodeResourceProto* temp = availableresource_;
  availableresource_ = NULL;
  return temp;
}
inline void WorkerResourceInfo::set_allocated_availableresource(::NodeResourceProto* availableresource) {
  delete availableresource_;
  availableresource_ = availableresource;
  if (availableresource) {
    set_has_availableresource();
  } else {
    clear_has_availableresource();
  }
}

// required int32 numRunningTasks = 4;
inline bool WorkerResourceInfo::has_numrunningtasks() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WorkerResourceInfo::set_has_numrunningtasks() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WorkerResourceInfo::clear_has_numrunningtasks() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WorkerResourceInfo::clear_numrunningtasks() {
  numrunningtasks_ = 0;
  clear_has_numrunningtasks();
}
inline ::google::protobuf::int32 WorkerResourceInfo::numrunningtasks() const {
  return numrunningtasks_;
}
inline void WorkerResourceInfo::set_numrunningtasks(::google::protobuf::int32 value) {
  set_has_numrunningtasks();
  numrunningtasks_ = value;
}

// required string workerStatus = 5;
inline bool WorkerResourceInfo::has_workerstatus() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WorkerResourceInfo::set_has_workerstatus() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WorkerResourceInfo::clear_has_workerstatus() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WorkerResourceInfo::clear_workerstatus() {
  if (workerstatus_ != &::google::protobuf::internal::kEmptyString) {
    workerstatus_->clear();
  }
  clear_has_workerstatus();
}
inline const ::std::string& WorkerResourceInfo::workerstatus() const {
  return *workerstatus_;
}
inline void WorkerResourceInfo::set_workerstatus(const ::std::string& value) {
  set_has_workerstatus();
  if (workerstatus_ == &::google::protobuf::internal::kEmptyString) {
    workerstatus_ = new ::std::string;
  }
  workerstatus_->assign(value);
}
inline void WorkerResourceInfo::set_workerstatus(const char* value) {
  set_has_workerstatus();
  if (workerstatus_ == &::google::protobuf::internal::kEmptyString) {
    workerstatus_ = new ::std::string;
  }
  workerstatus_->assign(value);
}
inline void WorkerResourceInfo::set_workerstatus(const char* value, size_t size) {
  set_has_workerstatus();
  if (workerstatus_ == &::google::protobuf::internal::kEmptyString) {
    workerstatus_ = new ::std::string;
  }
  workerstatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WorkerResourceInfo::mutable_workerstatus() {
  set_has_workerstatus();
  if (workerstatus_ == &::google::protobuf::internal::kEmptyString) {
    workerstatus_ = new ::std::string;
  }
  return workerstatus_;
}
inline ::std::string* WorkerResourceInfo::release_workerstatus() {
  clear_has_workerstatus();
  if (workerstatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = workerstatus_;
    workerstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WorkerResourceInfo::set_allocated_workerstatus(::std::string* workerstatus) {
  if (workerstatus_ != &::google::protobuf::internal::kEmptyString) {
    delete workerstatus_;
  }
  if (workerstatus) {
    set_has_workerstatus();
    workerstatus_ = workerstatus;
  } else {
    clear_has_workerstatus();
    workerstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 lastHeartbeat = 6;
inline bool WorkerResourceInfo::has_lastheartbeat() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WorkerResourceInfo::set_has_lastheartbeat() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WorkerResourceInfo::clear_has_lastheartbeat() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WorkerResourceInfo::clear_lastheartbeat() {
  lastheartbeat_ = GOOGLE_LONGLONG(0);
  clear_has_lastheartbeat();
}
inline ::google::protobuf::int64 WorkerResourceInfo::lastheartbeat() const {
  return lastheartbeat_;
}
inline void WorkerResourceInfo::set_lastheartbeat(::google::protobuf::int64 value) {
  set_has_lastheartbeat();
  lastheartbeat_ = value;
}

// required int32 numQueryMasterTasks = 7;
inline bool WorkerResourceInfo::has_numquerymastertasks() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WorkerResourceInfo::set_has_numquerymastertasks() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WorkerResourceInfo::clear_has_numquerymastertasks() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WorkerResourceInfo::clear_numquerymastertasks() {
  numquerymastertasks_ = 0;
  clear_has_numquerymastertasks();
}
inline ::google::protobuf::int32 WorkerResourceInfo::numquerymastertasks() const {
  return numquerymastertasks_;
}
inline void WorkerResourceInfo::set_numquerymastertasks(::google::protobuf::int32 value) {
  set_has_numquerymastertasks();
  numquerymastertasks_ = value;
}

// -------------------------------------------------------------------

// GetClusterInfoResponse

// required .ReturnState state = 1;
inline bool GetClusterInfoResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetClusterInfoResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetClusterInfoResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetClusterInfoResponse::clear_state() {
  if (state_ != NULL) state_->::ReturnState::Clear();
  clear_has_state();
}
inline const ::ReturnState& GetClusterInfoResponse::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::ReturnState* GetClusterInfoResponse::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::ReturnState;
  return state_;
}
inline ::ReturnState* GetClusterInfoResponse::release_state() {
  clear_has_state();
  ::ReturnState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void GetClusterInfoResponse::set_allocated_state(::ReturnState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// repeated .tajo.client.WorkerResourceInfo workerList = 2;
inline int GetClusterInfoResponse::workerlist_size() const {
  return workerlist_.size();
}
inline void GetClusterInfoResponse::clear_workerlist() {
  workerlist_.Clear();
}
inline const ::tajo::client::WorkerResourceInfo& GetClusterInfoResponse::workerlist(int index) const {
  return workerlist_.Get(index);
}
inline ::tajo::client::WorkerResourceInfo* GetClusterInfoResponse::mutable_workerlist(int index) {
  return workerlist_.Mutable(index);
}
inline ::tajo::client::WorkerResourceInfo* GetClusterInfoResponse::add_workerlist() {
  return workerlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tajo::client::WorkerResourceInfo >&
GetClusterInfoResponse::workerlist() const {
  return workerlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::tajo::client::WorkerResourceInfo >*
GetClusterInfoResponse::mutable_workerlist() {
  return &workerlist_;
}

// -------------------------------------------------------------------

// CreateTableRequest

// optional .SessionIdProto sessionId = 1;
inline bool CreateTableRequest::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateTableRequest::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateTableRequest::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateTableRequest::clear_sessionid() {
  if (sessionid_ != NULL) sessionid_->::SessionIdProto::Clear();
  clear_has_sessionid();
}
inline const ::SessionIdProto& CreateTableRequest::sessionid() const {
  return sessionid_ != NULL ? *sessionid_ : *default_instance_->sessionid_;
}
inline ::SessionIdProto* CreateTableRequest::mutable_sessionid() {
  set_has_sessionid();
  if (sessionid_ == NULL) sessionid_ = new ::SessionIdProto;
  return sessionid_;
}
inline ::SessionIdProto* CreateTableRequest::release_sessionid() {
  clear_has_sessionid();
  ::SessionIdProto* temp = sessionid_;
  sessionid_ = NULL;
  return temp;
}
inline void CreateTableRequest::set_allocated_sessionid(::SessionIdProto* sessionid) {
  delete sessionid_;
  sessionid_ = sessionid;
  if (sessionid) {
    set_has_sessionid();
  } else {
    clear_has_sessionid();
  }
}

// required string name = 2;
inline bool CreateTableRequest::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateTableRequest::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateTableRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateTableRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CreateTableRequest::name() const {
  return *name_;
}
inline void CreateTableRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CreateTableRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CreateTableRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateTableRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CreateTableRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateTableRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SchemaProto schema = 3;
inline bool CreateTableRequest::has_schema() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateTableRequest::set_has_schema() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateTableRequest::clear_has_schema() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateTableRequest::clear_schema() {
  if (schema_ != NULL) schema_->::SchemaProto::Clear();
  clear_has_schema();
}
inline const ::SchemaProto& CreateTableRequest::schema() const {
  return schema_ != NULL ? *schema_ : *default_instance_->schema_;
}
inline ::SchemaProto* CreateTableRequest::mutable_schema() {
  set_has_schema();
  if (schema_ == NULL) schema_ = new ::SchemaProto;
  return schema_;
}
inline ::SchemaProto* CreateTableRequest::release_schema() {
  clear_has_schema();
  ::SchemaProto* temp = schema_;
  schema_ = NULL;
  return temp;
}
inline void CreateTableRequest::set_allocated_schema(::SchemaProto* schema) {
  delete schema_;
  schema_ = schema;
  if (schema) {
    set_has_schema();
  } else {
    clear_has_schema();
  }
}

// required .TableProto meta = 4;
inline bool CreateTableRequest::has_meta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateTableRequest::set_has_meta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateTableRequest::clear_has_meta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateTableRequest::clear_meta() {
  if (meta_ != NULL) meta_->::TableProto::Clear();
  clear_has_meta();
}
inline const ::TableProto& CreateTableRequest::meta() const {
  return meta_ != NULL ? *meta_ : *default_instance_->meta_;
}
inline ::TableProto* CreateTableRequest::mutable_meta() {
  set_has_meta();
  if (meta_ == NULL) meta_ = new ::TableProto;
  return meta_;
}
inline ::TableProto* CreateTableRequest::release_meta() {
  clear_has_meta();
  ::TableProto* temp = meta_;
  meta_ = NULL;
  return temp;
}
inline void CreateTableRequest::set_allocated_meta(::TableProto* meta) {
  delete meta_;
  meta_ = meta;
  if (meta) {
    set_has_meta();
  } else {
    clear_has_meta();
  }
}

// required string path = 5;
inline bool CreateTableRequest::has_path() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateTableRequest::set_has_path() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateTableRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateTableRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& CreateTableRequest::path() const {
  return *path_;
}
inline void CreateTableRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void CreateTableRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void CreateTableRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateTableRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* CreateTableRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateTableRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .PartitionMethodProto partition = 6;
inline bool CreateTableRequest::has_partition() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreateTableRequest::set_has_partition() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreateTableRequest::clear_has_partition() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreateTableRequest::clear_partition() {
  if (partition_ != NULL) partition_->::PartitionMethodProto::Clear();
  clear_has_partition();
}
inline const ::PartitionMethodProto& CreateTableRequest::partition() const {
  return partition_ != NULL ? *partition_ : *default_instance_->partition_;
}
inline ::PartitionMethodProto* CreateTableRequest::mutable_partition() {
  set_has_partition();
  if (partition_ == NULL) partition_ = new ::PartitionMethodProto;
  return partition_;
}
inline ::PartitionMethodProto* CreateTableRequest::release_partition() {
  clear_has_partition();
  ::PartitionMethodProto* temp = partition_;
  partition_ = NULL;
  return temp;
}
inline void CreateTableRequest::set_allocated_partition(::PartitionMethodProto* partition) {
  delete partition_;
  partition_ = partition;
  if (partition) {
    set_has_partition();
  } else {
    clear_has_partition();
  }
}

// -------------------------------------------------------------------

// DropTableRequest

// optional .SessionIdProto sessionId = 1;
inline bool DropTableRequest::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DropTableRequest::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DropTableRequest::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DropTableRequest::clear_sessionid() {
  if (sessionid_ != NULL) sessionid_->::SessionIdProto::Clear();
  clear_has_sessionid();
}
inline const ::SessionIdProto& DropTableRequest::sessionid() const {
  return sessionid_ != NULL ? *sessionid_ : *default_instance_->sessionid_;
}
inline ::SessionIdProto* DropTableRequest::mutable_sessionid() {
  set_has_sessionid();
  if (sessionid_ == NULL) sessionid_ = new ::SessionIdProto;
  return sessionid_;
}
inline ::SessionIdProto* DropTableRequest::release_sessionid() {
  clear_has_sessionid();
  ::SessionIdProto* temp = sessionid_;
  sessionid_ = NULL;
  return temp;
}
inline void DropTableRequest::set_allocated_sessionid(::SessionIdProto* sessionid) {
  delete sessionid_;
  sessionid_ = sessionid;
  if (sessionid) {
    set_has_sessionid();
  } else {
    clear_has_sessionid();
  }
}

// required string name = 2;
inline bool DropTableRequest::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DropTableRequest::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DropTableRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DropTableRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DropTableRequest::name() const {
  return *name_;
}
inline void DropTableRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DropTableRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DropTableRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DropTableRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* DropTableRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DropTableRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool purge = 3 [default = false];
inline bool DropTableRequest::has_purge() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DropTableRequest::set_has_purge() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DropTableRequest::clear_has_purge() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DropTableRequest::clear_purge() {
  purge_ = false;
  clear_has_purge();
}
inline bool DropTableRequest::purge() const {
  return purge_;
}
inline void DropTableRequest::set_purge(bool value) {
  set_has_purge();
  purge_ = value;
}

// -------------------------------------------------------------------

// QueryInfoProto

// required string queryId = 1;
inline bool QueryInfoProto::has_queryid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryInfoProto::set_has_queryid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryInfoProto::clear_has_queryid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryInfoProto::clear_queryid() {
  if (queryid_ != &::google::protobuf::internal::kEmptyString) {
    queryid_->clear();
  }
  clear_has_queryid();
}
inline const ::std::string& QueryInfoProto::queryid() const {
  return *queryid_;
}
inline void QueryInfoProto::set_queryid(const ::std::string& value) {
  set_has_queryid();
  if (queryid_ == &::google::protobuf::internal::kEmptyString) {
    queryid_ = new ::std::string;
  }
  queryid_->assign(value);
}
inline void QueryInfoProto::set_queryid(const char* value) {
  set_has_queryid();
  if (queryid_ == &::google::protobuf::internal::kEmptyString) {
    queryid_ = new ::std::string;
  }
  queryid_->assign(value);
}
inline void QueryInfoProto::set_queryid(const char* value, size_t size) {
  set_has_queryid();
  if (queryid_ == &::google::protobuf::internal::kEmptyString) {
    queryid_ = new ::std::string;
  }
  queryid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryInfoProto::mutable_queryid() {
  set_has_queryid();
  if (queryid_ == &::google::protobuf::internal::kEmptyString) {
    queryid_ = new ::std::string;
  }
  return queryid_;
}
inline ::std::string* QueryInfoProto::release_queryid() {
  clear_has_queryid();
  if (queryid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = queryid_;
    queryid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryInfoProto::set_allocated_queryid(::std::string* queryid) {
  if (queryid_ != &::google::protobuf::internal::kEmptyString) {
    delete queryid_;
  }
  if (queryid) {
    set_has_queryid();
    queryid_ = queryid;
  } else {
    clear_has_queryid();
    queryid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sql = 2;
inline bool QueryInfoProto::has_sql() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryInfoProto::set_has_sql() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryInfoProto::clear_has_sql() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryInfoProto::clear_sql() {
  if (sql_ != &::google::protobuf::internal::kEmptyString) {
    sql_->clear();
  }
  clear_has_sql();
}
inline const ::std::string& QueryInfoProto::sql() const {
  return *sql_;
}
inline void QueryInfoProto::set_sql(const ::std::string& value) {
  set_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    sql_ = new ::std::string;
  }
  sql_->assign(value);
}
inline void QueryInfoProto::set_sql(const char* value) {
  set_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    sql_ = new ::std::string;
  }
  sql_->assign(value);
}
inline void QueryInfoProto::set_sql(const char* value, size_t size) {
  set_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    sql_ = new ::std::string;
  }
  sql_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryInfoProto::mutable_sql() {
  set_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    sql_ = new ::std::string;
  }
  return sql_;
}
inline ::std::string* QueryInfoProto::release_sql() {
  clear_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sql_;
    sql_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryInfoProto::set_allocated_sql(::std::string* sql) {
  if (sql_ != &::google::protobuf::internal::kEmptyString) {
    delete sql_;
  }
  if (sql) {
    set_has_sql();
    sql_ = sql;
  } else {
    clear_has_sql();
    sql_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .KeyValueSetProto contextVars = 3;
inline bool QueryInfoProto::has_contextvars() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryInfoProto::set_has_contextvars() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryInfoProto::clear_has_contextvars() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryInfoProto::clear_contextvars() {
  if (contextvars_ != NULL) contextvars_->::KeyValueSetProto::Clear();
  clear_has_contextvars();
}
inline const ::KeyValueSetProto& QueryInfoProto::contextvars() const {
  return contextvars_ != NULL ? *contextvars_ : *default_instance_->contextvars_;
}
inline ::KeyValueSetProto* QueryInfoProto::mutable_contextvars() {
  set_has_contextvars();
  if (contextvars_ == NULL) contextvars_ = new ::KeyValueSetProto;
  return contextvars_;
}
inline ::KeyValueSetProto* QueryInfoProto::release_contextvars() {
  clear_has_contextvars();
  ::KeyValueSetProto* temp = contextvars_;
  contextvars_ = NULL;
  return temp;
}
inline void QueryInfoProto::set_allocated_contextvars(::KeyValueSetProto* contextvars) {
  delete contextvars_;
  contextvars_ = contextvars;
  if (contextvars) {
    set_has_contextvars();
  } else {
    clear_has_contextvars();
  }
}

// optional .QueryState queryState = 4;
inline bool QueryInfoProto::has_querystate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QueryInfoProto::set_has_querystate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QueryInfoProto::clear_has_querystate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QueryInfoProto::clear_querystate() {
  querystate_ = 0;
  clear_has_querystate();
}
inline ::QueryState QueryInfoProto::querystate() const {
  return static_cast< ::QueryState >(querystate_);
}
inline void QueryInfoProto::set_querystate(::QueryState value) {
  assert(::QueryState_IsValid(value));
  set_has_querystate();
  querystate_ = value;
}

// optional float progress = 5;
inline bool QueryInfoProto::has_progress() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void QueryInfoProto::set_has_progress() {
  _has_bits_[0] |= 0x00000010u;
}
inline void QueryInfoProto::clear_has_progress() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void QueryInfoProto::clear_progress() {
  progress_ = 0;
  clear_has_progress();
}
inline float QueryInfoProto::progress() const {
  return progress_;
}
inline void QueryInfoProto::set_progress(float value) {
  set_has_progress();
  progress_ = value;
}

// optional int64 startTime = 6;
inline bool QueryInfoProto::has_starttime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void QueryInfoProto::set_has_starttime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void QueryInfoProto::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void QueryInfoProto::clear_starttime() {
  starttime_ = GOOGLE_LONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::int64 QueryInfoProto::starttime() const {
  return starttime_;
}
inline void QueryInfoProto::set_starttime(::google::protobuf::int64 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional int64 finishTime = 7;
inline bool QueryInfoProto::has_finishtime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void QueryInfoProto::set_has_finishtime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void QueryInfoProto::clear_has_finishtime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void QueryInfoProto::clear_finishtime() {
  finishtime_ = GOOGLE_LONGLONG(0);
  clear_has_finishtime();
}
inline ::google::protobuf::int64 QueryInfoProto::finishtime() const {
  return finishtime_;
}
inline void QueryInfoProto::set_finishtime(::google::protobuf::int64 value) {
  set_has_finishtime();
  finishtime_ = value;
}

// optional string lastMessage = 8;
inline bool QueryInfoProto::has_lastmessage() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void QueryInfoProto::set_has_lastmessage() {
  _has_bits_[0] |= 0x00000080u;
}
inline void QueryInfoProto::clear_has_lastmessage() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void QueryInfoProto::clear_lastmessage() {
  if (lastmessage_ != &::google::protobuf::internal::kEmptyString) {
    lastmessage_->clear();
  }
  clear_has_lastmessage();
}
inline const ::std::string& QueryInfoProto::lastmessage() const {
  return *lastmessage_;
}
inline void QueryInfoProto::set_lastmessage(const ::std::string& value) {
  set_has_lastmessage();
  if (lastmessage_ == &::google::protobuf::internal::kEmptyString) {
    lastmessage_ = new ::std::string;
  }
  lastmessage_->assign(value);
}
inline void QueryInfoProto::set_lastmessage(const char* value) {
  set_has_lastmessage();
  if (lastmessage_ == &::google::protobuf::internal::kEmptyString) {
    lastmessage_ = new ::std::string;
  }
  lastmessage_->assign(value);
}
inline void QueryInfoProto::set_lastmessage(const char* value, size_t size) {
  set_has_lastmessage();
  if (lastmessage_ == &::google::protobuf::internal::kEmptyString) {
    lastmessage_ = new ::std::string;
  }
  lastmessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryInfoProto::mutable_lastmessage() {
  set_has_lastmessage();
  if (lastmessage_ == &::google::protobuf::internal::kEmptyString) {
    lastmessage_ = new ::std::string;
  }
  return lastmessage_;
}
inline ::std::string* QueryInfoProto::release_lastmessage() {
  clear_has_lastmessage();
  if (lastmessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lastmessage_;
    lastmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryInfoProto::set_allocated_lastmessage(::std::string* lastmessage) {
  if (lastmessage_ != &::google::protobuf::internal::kEmptyString) {
    delete lastmessage_;
  }
  if (lastmessage) {
    set_has_lastmessage();
    lastmessage_ = lastmessage;
  } else {
    clear_has_lastmessage();
    lastmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string hostNameOfQM = 9;
inline bool QueryInfoProto::has_hostnameofqm() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void QueryInfoProto::set_has_hostnameofqm() {
  _has_bits_[0] |= 0x00000100u;
}
inline void QueryInfoProto::clear_has_hostnameofqm() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void QueryInfoProto::clear_hostnameofqm() {
  if (hostnameofqm_ != &::google::protobuf::internal::kEmptyString) {
    hostnameofqm_->clear();
  }
  clear_has_hostnameofqm();
}
inline const ::std::string& QueryInfoProto::hostnameofqm() const {
  return *hostnameofqm_;
}
inline void QueryInfoProto::set_hostnameofqm(const ::std::string& value) {
  set_has_hostnameofqm();
  if (hostnameofqm_ == &::google::protobuf::internal::kEmptyString) {
    hostnameofqm_ = new ::std::string;
  }
  hostnameofqm_->assign(value);
}
inline void QueryInfoProto::set_hostnameofqm(const char* value) {
  set_has_hostnameofqm();
  if (hostnameofqm_ == &::google::protobuf::internal::kEmptyString) {
    hostnameofqm_ = new ::std::string;
  }
  hostnameofqm_->assign(value);
}
inline void QueryInfoProto::set_hostnameofqm(const char* value, size_t size) {
  set_has_hostnameofqm();
  if (hostnameofqm_ == &::google::protobuf::internal::kEmptyString) {
    hostnameofqm_ = new ::std::string;
  }
  hostnameofqm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryInfoProto::mutable_hostnameofqm() {
  set_has_hostnameofqm();
  if (hostnameofqm_ == &::google::protobuf::internal::kEmptyString) {
    hostnameofqm_ = new ::std::string;
  }
  return hostnameofqm_;
}
inline ::std::string* QueryInfoProto::release_hostnameofqm() {
  clear_has_hostnameofqm();
  if (hostnameofqm_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostnameofqm_;
    hostnameofqm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryInfoProto::set_allocated_hostnameofqm(::std::string* hostnameofqm) {
  if (hostnameofqm_ != &::google::protobuf::internal::kEmptyString) {
    delete hostnameofqm_;
  }
  if (hostnameofqm) {
    set_has_hostnameofqm();
    hostnameofqm_ = hostnameofqm;
  } else {
    clear_has_hostnameofqm();
    hostnameofqm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 queryMasterPort = 10;
inline bool QueryInfoProto::has_querymasterport() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void QueryInfoProto::set_has_querymasterport() {
  _has_bits_[0] |= 0x00000200u;
}
inline void QueryInfoProto::clear_has_querymasterport() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void QueryInfoProto::clear_querymasterport() {
  querymasterport_ = 0;
  clear_has_querymasterport();
}
inline ::google::protobuf::int32 QueryInfoProto::querymasterport() const {
  return querymasterport_;
}
inline void QueryInfoProto::set_querymasterport(::google::protobuf::int32 value) {
  set_has_querymasterport();
  querymasterport_ = value;
}

// optional int32 queryMasterClientPort = 11;
inline bool QueryInfoProto::has_querymasterclientport() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void QueryInfoProto::set_has_querymasterclientport() {
  _has_bits_[0] |= 0x00000400u;
}
inline void QueryInfoProto::clear_has_querymasterclientport() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void QueryInfoProto::clear_querymasterclientport() {
  querymasterclientport_ = 0;
  clear_has_querymasterclientport();
}
inline ::google::protobuf::int32 QueryInfoProto::querymasterclientport() const {
  return querymasterclientport_;
}
inline void QueryInfoProto::set_querymasterclientport(::google::protobuf::int32 value) {
  set_has_querymasterclientport();
  querymasterclientport_ = value;
}

// optional int32 queryMasterInfoPort = 12;
inline bool QueryInfoProto::has_querymasterinfoport() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void QueryInfoProto::set_has_querymasterinfoport() {
  _has_bits_[0] |= 0x00000800u;
}
inline void QueryInfoProto::clear_has_querymasterinfoport() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void QueryInfoProto::clear_querymasterinfoport() {
  querymasterinfoport_ = 0;
  clear_has_querymasterinfoport();
}
inline ::google::protobuf::int32 QueryInfoProto::querymasterinfoport() const {
  return querymasterinfoport_;
}
inline void QueryInfoProto::set_querymasterinfoport(::google::protobuf::int32 value) {
  set_has_querymasterinfoport();
  querymasterinfoport_ = value;
}

// optional .TableDescProto resultDesc = 13;
inline bool QueryInfoProto::has_resultdesc() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void QueryInfoProto::set_has_resultdesc() {
  _has_bits_[0] |= 0x00001000u;
}
inline void QueryInfoProto::clear_has_resultdesc() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void QueryInfoProto::clear_resultdesc() {
  if (resultdesc_ != NULL) resultdesc_->::TableDescProto::Clear();
  clear_has_resultdesc();
}
inline const ::TableDescProto& QueryInfoProto::resultdesc() const {
  return resultdesc_ != NULL ? *resultdesc_ : *default_instance_->resultdesc_;
}
inline ::TableDescProto* QueryInfoProto::mutable_resultdesc() {
  set_has_resultdesc();
  if (resultdesc_ == NULL) resultdesc_ = new ::TableDescProto;
  return resultdesc_;
}
inline ::TableDescProto* QueryInfoProto::release_resultdesc() {
  clear_has_resultdesc();
  ::TableDescProto* temp = resultdesc_;
  resultdesc_ = NULL;
  return temp;
}
inline void QueryInfoProto::set_allocated_resultdesc(::TableDescProto* resultdesc) {
  delete resultdesc_;
  resultdesc_ = resultdesc;
  if (resultdesc) {
    set_has_resultdesc();
  } else {
    clear_has_resultdesc();
  }
}

// -------------------------------------------------------------------

// StageHistoryProto

// required string executionBlockId = 1;
inline bool StageHistoryProto::has_executionblockid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StageHistoryProto::set_has_executionblockid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StageHistoryProto::clear_has_executionblockid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StageHistoryProto::clear_executionblockid() {
  if (executionblockid_ != &::google::protobuf::internal::kEmptyString) {
    executionblockid_->clear();
  }
  clear_has_executionblockid();
}
inline const ::std::string& StageHistoryProto::executionblockid() const {
  return *executionblockid_;
}
inline void StageHistoryProto::set_executionblockid(const ::std::string& value) {
  set_has_executionblockid();
  if (executionblockid_ == &::google::protobuf::internal::kEmptyString) {
    executionblockid_ = new ::std::string;
  }
  executionblockid_->assign(value);
}
inline void StageHistoryProto::set_executionblockid(const char* value) {
  set_has_executionblockid();
  if (executionblockid_ == &::google::protobuf::internal::kEmptyString) {
    executionblockid_ = new ::std::string;
  }
  executionblockid_->assign(value);
}
inline void StageHistoryProto::set_executionblockid(const char* value, size_t size) {
  set_has_executionblockid();
  if (executionblockid_ == &::google::protobuf::internal::kEmptyString) {
    executionblockid_ = new ::std::string;
  }
  executionblockid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StageHistoryProto::mutable_executionblockid() {
  set_has_executionblockid();
  if (executionblockid_ == &::google::protobuf::internal::kEmptyString) {
    executionblockid_ = new ::std::string;
  }
  return executionblockid_;
}
inline ::std::string* StageHistoryProto::release_executionblockid() {
  clear_has_executionblockid();
  if (executionblockid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = executionblockid_;
    executionblockid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StageHistoryProto::set_allocated_executionblockid(::std::string* executionblockid) {
  if (executionblockid_ != &::google::protobuf::internal::kEmptyString) {
    delete executionblockid_;
  }
  if (executionblockid) {
    set_has_executionblockid();
    executionblockid_ = executionblockid;
  } else {
    clear_has_executionblockid();
    executionblockid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string state = 2;
inline bool StageHistoryProto::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StageHistoryProto::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StageHistoryProto::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StageHistoryProto::clear_state() {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    state_->clear();
  }
  clear_has_state();
}
inline const ::std::string& StageHistoryProto::state() const {
  return *state_;
}
inline void StageHistoryProto::set_state(const ::std::string& value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void StageHistoryProto::set_state(const char* value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void StageHistoryProto::set_state(const char* value, size_t size) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StageHistoryProto::mutable_state() {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  return state_;
}
inline ::std::string* StageHistoryProto::release_state() {
  clear_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_;
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StageHistoryProto::set_allocated_state(::std::string* state) {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    delete state_;
  }
  if (state) {
    set_has_state();
    state_ = state;
  } else {
    clear_has_state();
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 startTime = 3;
inline bool StageHistoryProto::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StageHistoryProto::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StageHistoryProto::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StageHistoryProto::clear_starttime() {
  starttime_ = GOOGLE_LONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::int64 StageHistoryProto::starttime() const {
  return starttime_;
}
inline void StageHistoryProto::set_starttime(::google::protobuf::int64 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional int64 finishTime = 4;
inline bool StageHistoryProto::has_finishtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StageHistoryProto::set_has_finishtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StageHistoryProto::clear_has_finishtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StageHistoryProto::clear_finishtime() {
  finishtime_ = GOOGLE_LONGLONG(0);
  clear_has_finishtime();
}
inline ::google::protobuf::int64 StageHistoryProto::finishtime() const {
  return finishtime_;
}
inline void StageHistoryProto::set_finishtime(::google::protobuf::int64 value) {
  set_has_finishtime();
  finishtime_ = value;
}

// optional int32 succeededObjectCount = 5;
inline bool StageHistoryProto::has_succeededobjectcount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StageHistoryProto::set_has_succeededobjectcount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StageHistoryProto::clear_has_succeededobjectcount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StageHistoryProto::clear_succeededobjectcount() {
  succeededobjectcount_ = 0;
  clear_has_succeededobjectcount();
}
inline ::google::protobuf::int32 StageHistoryProto::succeededobjectcount() const {
  return succeededobjectcount_;
}
inline void StageHistoryProto::set_succeededobjectcount(::google::protobuf::int32 value) {
  set_has_succeededobjectcount();
  succeededobjectcount_ = value;
}

// optional int32 failedObjectCount = 6;
inline bool StageHistoryProto::has_failedobjectcount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StageHistoryProto::set_has_failedobjectcount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StageHistoryProto::clear_has_failedobjectcount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StageHistoryProto::clear_failedobjectcount() {
  failedobjectcount_ = 0;
  clear_has_failedobjectcount();
}
inline ::google::protobuf::int32 StageHistoryProto::failedobjectcount() const {
  return failedobjectcount_;
}
inline void StageHistoryProto::set_failedobjectcount(::google::protobuf::int32 value) {
  set_has_failedobjectcount();
  failedobjectcount_ = value;
}

// optional int32 killedObjectCount = 7;
inline bool StageHistoryProto::has_killedobjectcount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StageHistoryProto::set_has_killedobjectcount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StageHistoryProto::clear_has_killedobjectcount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StageHistoryProto::clear_killedobjectcount() {
  killedobjectcount_ = 0;
  clear_has_killedobjectcount();
}
inline ::google::protobuf::int32 StageHistoryProto::killedobjectcount() const {
  return killedobjectcount_;
}
inline void StageHistoryProto::set_killedobjectcount(::google::protobuf::int32 value) {
  set_has_killedobjectcount();
  killedobjectcount_ = value;
}

// optional int32 totalScheduledObjectsCount = 8;
inline bool StageHistoryProto::has_totalscheduledobjectscount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StageHistoryProto::set_has_totalscheduledobjectscount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StageHistoryProto::clear_has_totalscheduledobjectscount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StageHistoryProto::clear_totalscheduledobjectscount() {
  totalscheduledobjectscount_ = 0;
  clear_has_totalscheduledobjectscount();
}
inline ::google::protobuf::int32 StageHistoryProto::totalscheduledobjectscount() const {
  return totalscheduledobjectscount_;
}
inline void StageHistoryProto::set_totalscheduledobjectscount(::google::protobuf::int32 value) {
  set_has_totalscheduledobjectscount();
  totalscheduledobjectscount_ = value;
}

// optional int64 totalInputBytes = 9;
inline bool StageHistoryProto::has_totalinputbytes() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StageHistoryProto::set_has_totalinputbytes() {
  _has_bits_[0] |= 0x00000100u;
}
inline void StageHistoryProto::clear_has_totalinputbytes() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void StageHistoryProto::clear_totalinputbytes() {
  totalinputbytes_ = GOOGLE_LONGLONG(0);
  clear_has_totalinputbytes();
}
inline ::google::protobuf::int64 StageHistoryProto::totalinputbytes() const {
  return totalinputbytes_;
}
inline void StageHistoryProto::set_totalinputbytes(::google::protobuf::int64 value) {
  set_has_totalinputbytes();
  totalinputbytes_ = value;
}

// optional int64 totalReadBytes = 10;
inline bool StageHistoryProto::has_totalreadbytes() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void StageHistoryProto::set_has_totalreadbytes() {
  _has_bits_[0] |= 0x00000200u;
}
inline void StageHistoryProto::clear_has_totalreadbytes() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void StageHistoryProto::clear_totalreadbytes() {
  totalreadbytes_ = GOOGLE_LONGLONG(0);
  clear_has_totalreadbytes();
}
inline ::google::protobuf::int64 StageHistoryProto::totalreadbytes() const {
  return totalreadbytes_;
}
inline void StageHistoryProto::set_totalreadbytes(::google::protobuf::int64 value) {
  set_has_totalreadbytes();
  totalreadbytes_ = value;
}

// optional int64 totalReadRows = 11;
inline bool StageHistoryProto::has_totalreadrows() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void StageHistoryProto::set_has_totalreadrows() {
  _has_bits_[0] |= 0x00000400u;
}
inline void StageHistoryProto::clear_has_totalreadrows() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void StageHistoryProto::clear_totalreadrows() {
  totalreadrows_ = GOOGLE_LONGLONG(0);
  clear_has_totalreadrows();
}
inline ::google::protobuf::int64 StageHistoryProto::totalreadrows() const {
  return totalreadrows_;
}
inline void StageHistoryProto::set_totalreadrows(::google::protobuf::int64 value) {
  set_has_totalreadrows();
  totalreadrows_ = value;
}

// optional int64 totalWriteBytes = 12;
inline bool StageHistoryProto::has_totalwritebytes() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void StageHistoryProto::set_has_totalwritebytes() {
  _has_bits_[0] |= 0x00000800u;
}
inline void StageHistoryProto::clear_has_totalwritebytes() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void StageHistoryProto::clear_totalwritebytes() {
  totalwritebytes_ = GOOGLE_LONGLONG(0);
  clear_has_totalwritebytes();
}
inline ::google::protobuf::int64 StageHistoryProto::totalwritebytes() const {
  return totalwritebytes_;
}
inline void StageHistoryProto::set_totalwritebytes(::google::protobuf::int64 value) {
  set_has_totalwritebytes();
  totalwritebytes_ = value;
}

// optional int64 totalWriteRows = 13;
inline bool StageHistoryProto::has_totalwriterows() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void StageHistoryProto::set_has_totalwriterows() {
  _has_bits_[0] |= 0x00001000u;
}
inline void StageHistoryProto::clear_has_totalwriterows() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void StageHistoryProto::clear_totalwriterows() {
  totalwriterows_ = GOOGLE_LONGLONG(0);
  clear_has_totalwriterows();
}
inline ::google::protobuf::int64 StageHistoryProto::totalwriterows() const {
  return totalwriterows_;
}
inline void StageHistoryProto::set_totalwriterows(::google::protobuf::int64 value) {
  set_has_totalwriterows();
  totalwriterows_ = value;
}

// optional int32 numShuffles = 14;
inline bool StageHistoryProto::has_numshuffles() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void StageHistoryProto::set_has_numshuffles() {
  _has_bits_[0] |= 0x00002000u;
}
inline void StageHistoryProto::clear_has_numshuffles() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void StageHistoryProto::clear_numshuffles() {
  numshuffles_ = 0;
  clear_has_numshuffles();
}
inline ::google::protobuf::int32 StageHistoryProto::numshuffles() const {
  return numshuffles_;
}
inline void StageHistoryProto::set_numshuffles(::google::protobuf::int32 value) {
  set_has_numshuffles();
  numshuffles_ = value;
}

// optional float progress = 15;
inline bool StageHistoryProto::has_progress() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void StageHistoryProto::set_has_progress() {
  _has_bits_[0] |= 0x00004000u;
}
inline void StageHistoryProto::clear_has_progress() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void StageHistoryProto::clear_progress() {
  progress_ = 0;
  clear_has_progress();
}
inline float StageHistoryProto::progress() const {
  return progress_;
}
inline void StageHistoryProto::set_progress(float value) {
  set_has_progress();
  progress_ = value;
}

// optional string plan = 16;
inline bool StageHistoryProto::has_plan() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void StageHistoryProto::set_has_plan() {
  _has_bits_[0] |= 0x00008000u;
}
inline void StageHistoryProto::clear_has_plan() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void StageHistoryProto::clear_plan() {
  if (plan_ != &::google::protobuf::internal::kEmptyString) {
    plan_->clear();
  }
  clear_has_plan();
}
inline const ::std::string& StageHistoryProto::plan() const {
  return *plan_;
}
inline void StageHistoryProto::set_plan(const ::std::string& value) {
  set_has_plan();
  if (plan_ == &::google::protobuf::internal::kEmptyString) {
    plan_ = new ::std::string;
  }
  plan_->assign(value);
}
inline void StageHistoryProto::set_plan(const char* value) {
  set_has_plan();
  if (plan_ == &::google::protobuf::internal::kEmptyString) {
    plan_ = new ::std::string;
  }
  plan_->assign(value);
}
inline void StageHistoryProto::set_plan(const char* value, size_t size) {
  set_has_plan();
  if (plan_ == &::google::protobuf::internal::kEmptyString) {
    plan_ = new ::std::string;
  }
  plan_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StageHistoryProto::mutable_plan() {
  set_has_plan();
  if (plan_ == &::google::protobuf::internal::kEmptyString) {
    plan_ = new ::std::string;
  }
  return plan_;
}
inline ::std::string* StageHistoryProto::release_plan() {
  clear_has_plan();
  if (plan_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = plan_;
    plan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StageHistoryProto::set_allocated_plan(::std::string* plan) {
  if (plan_ != &::google::protobuf::internal::kEmptyString) {
    delete plan_;
  }
  if (plan) {
    set_has_plan();
    plan_ = plan;
  } else {
    clear_has_plan();
    plan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 hostLocalAssigned = 17;
inline bool StageHistoryProto::has_hostlocalassigned() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void StageHistoryProto::set_has_hostlocalassigned() {
  _has_bits_[0] |= 0x00010000u;
}
inline void StageHistoryProto::clear_has_hostlocalassigned() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void StageHistoryProto::clear_hostlocalassigned() {
  hostlocalassigned_ = 0;
  clear_has_hostlocalassigned();
}
inline ::google::protobuf::int32 StageHistoryProto::hostlocalassigned() const {
  return hostlocalassigned_;
}
inline void StageHistoryProto::set_hostlocalassigned(::google::protobuf::int32 value) {
  set_has_hostlocalassigned();
  hostlocalassigned_ = value;
}

// optional int32 rackLocalAssigned = 18;
inline bool StageHistoryProto::has_racklocalassigned() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void StageHistoryProto::set_has_racklocalassigned() {
  _has_bits_[0] |= 0x00020000u;
}
inline void StageHistoryProto::clear_has_racklocalassigned() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void StageHistoryProto::clear_racklocalassigned() {
  racklocalassigned_ = 0;
  clear_has_racklocalassigned();
}
inline ::google::protobuf::int32 StageHistoryProto::racklocalassigned() const {
  return racklocalassigned_;
}
inline void StageHistoryProto::set_racklocalassigned(::google::protobuf::int32 value) {
  set_has_racklocalassigned();
  racklocalassigned_ = value;
}

// -------------------------------------------------------------------

// QueryHistoryProto

// required string queryId = 1;
inline bool QueryHistoryProto::has_queryid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryHistoryProto::set_has_queryid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryHistoryProto::clear_has_queryid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryHistoryProto::clear_queryid() {
  if (queryid_ != &::google::protobuf::internal::kEmptyString) {
    queryid_->clear();
  }
  clear_has_queryid();
}
inline const ::std::string& QueryHistoryProto::queryid() const {
  return *queryid_;
}
inline void QueryHistoryProto::set_queryid(const ::std::string& value) {
  set_has_queryid();
  if (queryid_ == &::google::protobuf::internal::kEmptyString) {
    queryid_ = new ::std::string;
  }
  queryid_->assign(value);
}
inline void QueryHistoryProto::set_queryid(const char* value) {
  set_has_queryid();
  if (queryid_ == &::google::protobuf::internal::kEmptyString) {
    queryid_ = new ::std::string;
  }
  queryid_->assign(value);
}
inline void QueryHistoryProto::set_queryid(const char* value, size_t size) {
  set_has_queryid();
  if (queryid_ == &::google::protobuf::internal::kEmptyString) {
    queryid_ = new ::std::string;
  }
  queryid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryHistoryProto::mutable_queryid() {
  set_has_queryid();
  if (queryid_ == &::google::protobuf::internal::kEmptyString) {
    queryid_ = new ::std::string;
  }
  return queryid_;
}
inline ::std::string* QueryHistoryProto::release_queryid() {
  clear_has_queryid();
  if (queryid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = queryid_;
    queryid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryHistoryProto::set_allocated_queryid(::std::string* queryid) {
  if (queryid_ != &::google::protobuf::internal::kEmptyString) {
    delete queryid_;
  }
  if (queryid) {
    set_has_queryid();
    queryid_ = queryid;
  } else {
    clear_has_queryid();
    queryid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string queryMaster = 2;
inline bool QueryHistoryProto::has_querymaster() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryHistoryProto::set_has_querymaster() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryHistoryProto::clear_has_querymaster() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryHistoryProto::clear_querymaster() {
  if (querymaster_ != &::google::protobuf::internal::kEmptyString) {
    querymaster_->clear();
  }
  clear_has_querymaster();
}
inline const ::std::string& QueryHistoryProto::querymaster() const {
  return *querymaster_;
}
inline void QueryHistoryProto::set_querymaster(const ::std::string& value) {
  set_has_querymaster();
  if (querymaster_ == &::google::protobuf::internal::kEmptyString) {
    querymaster_ = new ::std::string;
  }
  querymaster_->assign(value);
}
inline void QueryHistoryProto::set_querymaster(const char* value) {
  set_has_querymaster();
  if (querymaster_ == &::google::protobuf::internal::kEmptyString) {
    querymaster_ = new ::std::string;
  }
  querymaster_->assign(value);
}
inline void QueryHistoryProto::set_querymaster(const char* value, size_t size) {
  set_has_querymaster();
  if (querymaster_ == &::google::protobuf::internal::kEmptyString) {
    querymaster_ = new ::std::string;
  }
  querymaster_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryHistoryProto::mutable_querymaster() {
  set_has_querymaster();
  if (querymaster_ == &::google::protobuf::internal::kEmptyString) {
    querymaster_ = new ::std::string;
  }
  return querymaster_;
}
inline ::std::string* QueryHistoryProto::release_querymaster() {
  clear_has_querymaster();
  if (querymaster_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = querymaster_;
    querymaster_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryHistoryProto::set_allocated_querymaster(::std::string* querymaster) {
  if (querymaster_ != &::google::protobuf::internal::kEmptyString) {
    delete querymaster_;
  }
  if (querymaster) {
    set_has_querymaster();
    querymaster_ = querymaster;
  } else {
    clear_has_querymaster();
    querymaster_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 httpPort = 3;
inline bool QueryHistoryProto::has_httpport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryHistoryProto::set_has_httpport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryHistoryProto::clear_has_httpport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryHistoryProto::clear_httpport() {
  httpport_ = 0;
  clear_has_httpport();
}
inline ::google::protobuf::int32 QueryHistoryProto::httpport() const {
  return httpport_;
}
inline void QueryHistoryProto::set_httpport(::google::protobuf::int32 value) {
  set_has_httpport();
  httpport_ = value;
}

// optional string logicalPlan = 4;
inline bool QueryHistoryProto::has_logicalplan() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QueryHistoryProto::set_has_logicalplan() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QueryHistoryProto::clear_has_logicalplan() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QueryHistoryProto::clear_logicalplan() {
  if (logicalplan_ != &::google::protobuf::internal::kEmptyString) {
    logicalplan_->clear();
  }
  clear_has_logicalplan();
}
inline const ::std::string& QueryHistoryProto::logicalplan() const {
  return *logicalplan_;
}
inline void QueryHistoryProto::set_logicalplan(const ::std::string& value) {
  set_has_logicalplan();
  if (logicalplan_ == &::google::protobuf::internal::kEmptyString) {
    logicalplan_ = new ::std::string;
  }
  logicalplan_->assign(value);
}
inline void QueryHistoryProto::set_logicalplan(const char* value) {
  set_has_logicalplan();
  if (logicalplan_ == &::google::protobuf::internal::kEmptyString) {
    logicalplan_ = new ::std::string;
  }
  logicalplan_->assign(value);
}
inline void QueryHistoryProto::set_logicalplan(const char* value, size_t size) {
  set_has_logicalplan();
  if (logicalplan_ == &::google::protobuf::internal::kEmptyString) {
    logicalplan_ = new ::std::string;
  }
  logicalplan_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryHistoryProto::mutable_logicalplan() {
  set_has_logicalplan();
  if (logicalplan_ == &::google::protobuf::internal::kEmptyString) {
    logicalplan_ = new ::std::string;
  }
  return logicalplan_;
}
inline ::std::string* QueryHistoryProto::release_logicalplan() {
  clear_has_logicalplan();
  if (logicalplan_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = logicalplan_;
    logicalplan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryHistoryProto::set_allocated_logicalplan(::std::string* logicalplan) {
  if (logicalplan_ != &::google::protobuf::internal::kEmptyString) {
    delete logicalplan_;
  }
  if (logicalplan) {
    set_has_logicalplan();
    logicalplan_ = logicalplan;
  } else {
    clear_has_logicalplan();
    logicalplan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string distributedPlan = 5;
inline bool QueryHistoryProto::has_distributedplan() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void QueryHistoryProto::set_has_distributedplan() {
  _has_bits_[0] |= 0x00000010u;
}
inline void QueryHistoryProto::clear_has_distributedplan() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void QueryHistoryProto::clear_distributedplan() {
  if (distributedplan_ != &::google::protobuf::internal::kEmptyString) {
    distributedplan_->clear();
  }
  clear_has_distributedplan();
}
inline const ::std::string& QueryHistoryProto::distributedplan() const {
  return *distributedplan_;
}
inline void QueryHistoryProto::set_distributedplan(const ::std::string& value) {
  set_has_distributedplan();
  if (distributedplan_ == &::google::protobuf::internal::kEmptyString) {
    distributedplan_ = new ::std::string;
  }
  distributedplan_->assign(value);
}
inline void QueryHistoryProto::set_distributedplan(const char* value) {
  set_has_distributedplan();
  if (distributedplan_ == &::google::protobuf::internal::kEmptyString) {
    distributedplan_ = new ::std::string;
  }
  distributedplan_->assign(value);
}
inline void QueryHistoryProto::set_distributedplan(const char* value, size_t size) {
  set_has_distributedplan();
  if (distributedplan_ == &::google::protobuf::internal::kEmptyString) {
    distributedplan_ = new ::std::string;
  }
  distributedplan_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryHistoryProto::mutable_distributedplan() {
  set_has_distributedplan();
  if (distributedplan_ == &::google::protobuf::internal::kEmptyString) {
    distributedplan_ = new ::std::string;
  }
  return distributedplan_;
}
inline ::std::string* QueryHistoryProto::release_distributedplan() {
  clear_has_distributedplan();
  if (distributedplan_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = distributedplan_;
    distributedplan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryHistoryProto::set_allocated_distributedplan(::std::string* distributedplan) {
  if (distributedplan_ != &::google::protobuf::internal::kEmptyString) {
    delete distributedplan_;
  }
  if (distributedplan) {
    set_has_distributedplan();
    distributedplan_ = distributedplan;
  } else {
    clear_has_distributedplan();
    distributedplan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .KeyValueProto sessionVariables = 6;
inline int QueryHistoryProto::sessionvariables_size() const {
  return sessionvariables_.size();
}
inline void QueryHistoryProto::clear_sessionvariables() {
  sessionvariables_.Clear();
}
inline const ::KeyValueProto& QueryHistoryProto::sessionvariables(int index) const {
  return sessionvariables_.Get(index);
}
inline ::KeyValueProto* QueryHistoryProto::mutable_sessionvariables(int index) {
  return sessionvariables_.Mutable(index);
}
inline ::KeyValueProto* QueryHistoryProto::add_sessionvariables() {
  return sessionvariables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KeyValueProto >&
QueryHistoryProto::sessionvariables() const {
  return sessionvariables_;
}
inline ::google::protobuf::RepeatedPtrField< ::KeyValueProto >*
QueryHistoryProto::mutable_sessionvariables() {
  return &sessionvariables_;
}

// repeated .tajo.client.StageHistoryProto stageHistories = 7;
inline int QueryHistoryProto::stagehistories_size() const {
  return stagehistories_.size();
}
inline void QueryHistoryProto::clear_stagehistories() {
  stagehistories_.Clear();
}
inline const ::tajo::client::StageHistoryProto& QueryHistoryProto::stagehistories(int index) const {
  return stagehistories_.Get(index);
}
inline ::tajo::client::StageHistoryProto* QueryHistoryProto::mutable_stagehistories(int index) {
  return stagehistories_.Mutable(index);
}
inline ::tajo::client::StageHistoryProto* QueryHistoryProto::add_stagehistories() {
  return stagehistories_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tajo::client::StageHistoryProto >&
QueryHistoryProto::stagehistories() const {
  return stagehistories_;
}
inline ::google::protobuf::RepeatedPtrField< ::tajo::client::StageHistoryProto >*
QueryHistoryProto::mutable_stagehistories() {
  return &stagehistories_;
}

// -------------------------------------------------------------------

// GetQueryHistoryResponse

// required .ReturnState state = 1;
inline bool GetQueryHistoryResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetQueryHistoryResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetQueryHistoryResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetQueryHistoryResponse::clear_state() {
  if (state_ != NULL) state_->::ReturnState::Clear();
  clear_has_state();
}
inline const ::ReturnState& GetQueryHistoryResponse::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::ReturnState* GetQueryHistoryResponse::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::ReturnState;
  return state_;
}
inline ::ReturnState* GetQueryHistoryResponse::release_state() {
  clear_has_state();
  ::ReturnState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void GetQueryHistoryResponse::set_allocated_state(::ReturnState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// optional .tajo.client.QueryHistoryProto queryHistory = 2;
inline bool GetQueryHistoryResponse::has_queryhistory() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetQueryHistoryResponse::set_has_queryhistory() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetQueryHistoryResponse::clear_has_queryhistory() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetQueryHistoryResponse::clear_queryhistory() {
  if (queryhistory_ != NULL) queryhistory_->::tajo::client::QueryHistoryProto::Clear();
  clear_has_queryhistory();
}
inline const ::tajo::client::QueryHistoryProto& GetQueryHistoryResponse::queryhistory() const {
  return queryhistory_ != NULL ? *queryhistory_ : *default_instance_->queryhistory_;
}
inline ::tajo::client::QueryHistoryProto* GetQueryHistoryResponse::mutable_queryhistory() {
  set_has_queryhistory();
  if (queryhistory_ == NULL) queryhistory_ = new ::tajo::client::QueryHistoryProto;
  return queryhistory_;
}
inline ::tajo::client::QueryHistoryProto* GetQueryHistoryResponse::release_queryhistory() {
  clear_has_queryhistory();
  ::tajo::client::QueryHistoryProto* temp = queryhistory_;
  queryhistory_ = NULL;
  return temp;
}
inline void GetQueryHistoryResponse::set_allocated_queryhistory(::tajo::client::QueryHistoryProto* queryhistory) {
  delete queryhistory_;
  queryhistory_ = queryhistory;
  if (queryhistory) {
    set_has_queryhistory();
  } else {
    clear_has_queryhistory();
  }
}

// -------------------------------------------------------------------

// GetQueryInfoResponse

// required .ReturnState state = 1;
inline bool GetQueryInfoResponse::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetQueryInfoResponse::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetQueryInfoResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetQueryInfoResponse::clear_state() {
  if (state_ != NULL) state_->::ReturnState::Clear();
  clear_has_state();
}
inline const ::ReturnState& GetQueryInfoResponse::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::ReturnState* GetQueryInfoResponse::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::ReturnState;
  return state_;
}
inline ::ReturnState* GetQueryInfoResponse::release_state() {
  clear_has_state();
  ::ReturnState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void GetQueryInfoResponse::set_allocated_state(::ReturnState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// optional .tajo.client.QueryInfoProto queryInfo = 2;
inline bool GetQueryInfoResponse::has_queryinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetQueryInfoResponse::set_has_queryinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetQueryInfoResponse::clear_has_queryinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetQueryInfoResponse::clear_queryinfo() {
  if (queryinfo_ != NULL) queryinfo_->::tajo::client::QueryInfoProto::Clear();
  clear_has_queryinfo();
}
inline const ::tajo::client::QueryInfoProto& GetQueryInfoResponse::queryinfo() const {
  return queryinfo_ != NULL ? *queryinfo_ : *default_instance_->queryinfo_;
}
inline ::tajo::client::QueryInfoProto* GetQueryInfoResponse::mutable_queryinfo() {
  set_has_queryinfo();
  if (queryinfo_ == NULL) queryinfo_ = new ::tajo::client::QueryInfoProto;
  return queryinfo_;
}
inline ::tajo::client::QueryInfoProto* GetQueryInfoResponse::release_queryinfo() {
  clear_has_queryinfo();
  ::tajo::client::QueryInfoProto* temp = queryinfo_;
  queryinfo_ = NULL;
  return temp;
}
inline void GetQueryInfoResponse::set_allocated_queryinfo(::tajo::client::QueryInfoProto* queryinfo) {
  delete queryinfo_;
  queryinfo_ = queryinfo;
  if (queryinfo) {
    set_has_queryinfo();
  } else {
    clear_has_queryinfo();
  }
}

// -------------------------------------------------------------------

// CreateIndexResponse

// required .ReturnState result = 1;
inline bool CreateIndexResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateIndexResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateIndexResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateIndexResponse::clear_result() {
  if (result_ != NULL) result_->::ReturnState::Clear();
  clear_has_result();
}
inline const ::ReturnState& CreateIndexResponse::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ReturnState* CreateIndexResponse::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ReturnState;
  return result_;
}
inline ::ReturnState* CreateIndexResponse::release_result() {
  clear_has_result();
  ::ReturnState* temp = result_;
  result_ = NULL;
  return temp;
}
inline void CreateIndexResponse::set_allocated_result(::ReturnState* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional .IndexDescProto indexDesc = 2;
inline bool CreateIndexResponse::has_indexdesc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateIndexResponse::set_has_indexdesc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateIndexResponse::clear_has_indexdesc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateIndexResponse::clear_indexdesc() {
  if (indexdesc_ != NULL) indexdesc_->::IndexDescProto::Clear();
  clear_has_indexdesc();
}
inline const ::IndexDescProto& CreateIndexResponse::indexdesc() const {
  return indexdesc_ != NULL ? *indexdesc_ : *default_instance_->indexdesc_;
}
inline ::IndexDescProto* CreateIndexResponse::mutable_indexdesc() {
  set_has_indexdesc();
  if (indexdesc_ == NULL) indexdesc_ = new ::IndexDescProto;
  return indexdesc_;
}
inline ::IndexDescProto* CreateIndexResponse::release_indexdesc() {
  clear_has_indexdesc();
  ::IndexDescProto* temp = indexdesc_;
  indexdesc_ = NULL;
  return temp;
}
inline void CreateIndexResponse::set_allocated_indexdesc(::IndexDescProto* indexdesc) {
  delete indexdesc_;
  indexdesc_ = indexdesc;
  if (indexdesc) {
    set_has_indexdesc();
  } else {
    clear_has_indexdesc();
  }
}

// -------------------------------------------------------------------

// GetIndexWithColumnsRequest

// required .SessionIdProto sessionId = 1;
inline bool GetIndexWithColumnsRequest::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetIndexWithColumnsRequest::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetIndexWithColumnsRequest::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetIndexWithColumnsRequest::clear_sessionid() {
  if (sessionid_ != NULL) sessionid_->::SessionIdProto::Clear();
  clear_has_sessionid();
}
inline const ::SessionIdProto& GetIndexWithColumnsRequest::sessionid() const {
  return sessionid_ != NULL ? *sessionid_ : *default_instance_->sessionid_;
}
inline ::SessionIdProto* GetIndexWithColumnsRequest::mutable_sessionid() {
  set_has_sessionid();
  if (sessionid_ == NULL) sessionid_ = new ::SessionIdProto;
  return sessionid_;
}
inline ::SessionIdProto* GetIndexWithColumnsRequest::release_sessionid() {
  clear_has_sessionid();
  ::SessionIdProto* temp = sessionid_;
  sessionid_ = NULL;
  return temp;
}
inline void GetIndexWithColumnsRequest::set_allocated_sessionid(::SessionIdProto* sessionid) {
  delete sessionid_;
  sessionid_ = sessionid;
  if (sessionid) {
    set_has_sessionid();
  } else {
    clear_has_sessionid();
  }
}

// required string tableName = 2;
inline bool GetIndexWithColumnsRequest::has_tablename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetIndexWithColumnsRequest::set_has_tablename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetIndexWithColumnsRequest::clear_has_tablename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetIndexWithColumnsRequest::clear_tablename() {
  if (tablename_ != &::google::protobuf::internal::kEmptyString) {
    tablename_->clear();
  }
  clear_has_tablename();
}
inline const ::std::string& GetIndexWithColumnsRequest::tablename() const {
  return *tablename_;
}
inline void GetIndexWithColumnsRequest::set_tablename(const ::std::string& value) {
  set_has_tablename();
  if (tablename_ == &::google::protobuf::internal::kEmptyString) {
    tablename_ = new ::std::string;
  }
  tablename_->assign(value);
}
inline void GetIndexWithColumnsRequest::set_tablename(const char* value) {
  set_has_tablename();
  if (tablename_ == &::google::protobuf::internal::kEmptyString) {
    tablename_ = new ::std::string;
  }
  tablename_->assign(value);
}
inline void GetIndexWithColumnsRequest::set_tablename(const char* value, size_t size) {
  set_has_tablename();
  if (tablename_ == &::google::protobuf::internal::kEmptyString) {
    tablename_ = new ::std::string;
  }
  tablename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetIndexWithColumnsRequest::mutable_tablename() {
  set_has_tablename();
  if (tablename_ == &::google::protobuf::internal::kEmptyString) {
    tablename_ = new ::std::string;
  }
  return tablename_;
}
inline ::std::string* GetIndexWithColumnsRequest::release_tablename() {
  clear_has_tablename();
  if (tablename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tablename_;
    tablename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetIndexWithColumnsRequest::set_allocated_tablename(::std::string* tablename) {
  if (tablename_ != &::google::protobuf::internal::kEmptyString) {
    delete tablename_;
  }
  if (tablename) {
    set_has_tablename();
    tablename_ = tablename;
  } else {
    clear_has_tablename();
    tablename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string columnNames = 3;
inline int GetIndexWithColumnsRequest::columnnames_size() const {
  return columnnames_.size();
}
inline void GetIndexWithColumnsRequest::clear_columnnames() {
  columnnames_.Clear();
}
inline const ::std::string& GetIndexWithColumnsRequest::columnnames(int index) const {
  return columnnames_.Get(index);
}
inline ::std::string* GetIndexWithColumnsRequest::mutable_columnnames(int index) {
  return columnnames_.Mutable(index);
}
inline void GetIndexWithColumnsRequest::set_columnnames(int index, const ::std::string& value) {
  columnnames_.Mutable(index)->assign(value);
}
inline void GetIndexWithColumnsRequest::set_columnnames(int index, const char* value) {
  columnnames_.Mutable(index)->assign(value);
}
inline void GetIndexWithColumnsRequest::set_columnnames(int index, const char* value, size_t size) {
  columnnames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetIndexWithColumnsRequest::add_columnnames() {
  return columnnames_.Add();
}
inline void GetIndexWithColumnsRequest::add_columnnames(const ::std::string& value) {
  columnnames_.Add()->assign(value);
}
inline void GetIndexWithColumnsRequest::add_columnnames(const char* value) {
  columnnames_.Add()->assign(value);
}
inline void GetIndexWithColumnsRequest::add_columnnames(const char* value, size_t size) {
  columnnames_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetIndexWithColumnsRequest::columnnames() const {
  return columnnames_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetIndexWithColumnsRequest::mutable_columnnames() {
  return &columnnames_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace client
}  // namespace tajo

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tajo::client::SubmitQueryResponse_ResultType>() {
  return ::tajo::client::SubmitQueryResponse_ResultType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ClientProtos_2eproto__INCLUDED
